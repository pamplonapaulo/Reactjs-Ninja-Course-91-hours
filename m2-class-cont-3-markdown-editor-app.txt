"React.js Ninja" by Fernando Daciuk

* Module 2 *

Class Notes




        class #94 * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        App: Markdown Editor

        
        1.classes são statefull

        2.bind te permite subescrever o 'this' de um call feita:
          this.handleSubmit = this.handleSubmit.bind(this)
          sem ele, o target seria sempre o valor do próprio button clicado - o que não é nosso objetivo.

        3.arrow functions têm 'escopo léxico':
          o 'this' dentro de uma arrow func será o this do escopo da função de fora.

        4.jogue certos métodos dentro do constructor():
          utilize todos os métodos não específicos de life-cycle de react, jogue-os dentro do constructor(), pois assim poderá utilizar o próprio this do componente. Essa abordagem nos permite dispensar o uso excessivo de bind.

        piece of code:

          class App extends Component {
            constructor () {
              super()
              this.state = { value: ''}

              this.handleSubmit = (e) => {
                e.preventDefault()

                this.setState({
                  value: e.target.textarea.value
                })
              }
            }

            handleSubmit (e) {
              e.preventDefault()
              
              this.setState({
                value: e.target.textarea.value
              })
            }

            render () {
              return (
                blablablablabla...
              )
            }
          }

        class #95 * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        Melhorias

        Se tem-se um componente stateful (que manipula estado), você não deveria ter marcação (markup) nele.

        So insted of:

          class App extends Component {
            constructor () {
              super()
              this.state = { value: ''}

              this.handleChange = (e) => {

                this.setState({
                  value: e.target.value
                })
              }
            }

            handleSubmit (e) {
              e.preventDefault()
              
              this.setState({
                value: e.target.textarea.value
              })
            }

            render () {
              return (
                <div className='editor'>
                  <textarea value={this.state.value} onChange={this.handleChange}/>
                  
                  <div className="view">{this.state.value}</div>
                </div>
              )
            }
          }

        Correct would be:

          class App extends Component {
            constructor () {
              super()
              this.state = { value: ''}

              this.handleChange = (e) => {

                this.setState({
                  value: e.target.value
                })
              }
            }

            handleSubmit (e) {
              e.preventDefault()
              
              this.setState({
                value: e.target.textarea.value
              })
            }

            render () {
              return (
                <MardownEditor
                  value={this.state.value}
                  handleChange={this.handleChange}
                />
              )
            }
          }

          markdown-editor.js:

            'use strict'

            import React, { PropTypes } from 'react'

            const MarkdownEditor = ({ value, handleChange }) => (
              <div className='editor'>
                <textarea value={value} onChange={handleChange}/>
                
                <div className="view">{this.state.value}</div>
              </div>
            )

            MarkdownEditor.propTypes = {
              value: PropTypes.string.isRequired,
              handleChange: PropTypes.func.isRequired
            }

            export default MarkdownEditor

        class #96 * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

          Rendering HTML string in a component:

            dangerouslySetInnerHTML={{ __html: value}}


  class #97 * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

    Normalize.css:

    terminal:
    yarn add normalize.css

    webpack/common.js edits:

      const paths = {
        normalizeCss: join(__dirname, '..', 'node_modules', 'normalize.css')
      }

      cssLoader: {
        test: /\.css$/,
        include: [paths.src, paths.normalizeCss],
        use: ['style-loader', 'css-loader']
      }
    
    markdown-editor.js:
    import 'normalize.css'

  class #98 * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
  Rendering markdown code

  js lib to convert html string into markdown: marked
  https://github.com/markedjs/marked

  Terminal:
  yarn add marked

  app.js:
  import marked from 'marked'
  
  code:
  return { __html: marked(this.state.value) }

  class #99 * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
  colored markdown

  lib: highlight.js

  Terminal:
  yarn add highlight.js

  app.js:
  import highlight from 'highlight.js'

  code:
  marked.setOptions({
    highlight: (code) => {
      return highlight.highlightAuto(code).value
    }
  })

  highlight styles: dracula.css
  import 'highlight.js/styles/dracula.css'

  ajust in webpack/common.js:

  const paths = {
    highlightJs: join(__dirname, '..', 'node_modules', 'highlight.js', 'styles')
  }

  cssLoader: {
    test: /\.css$/,
    include: [paths.src, paths.normalizeCss, paths.highlightJs],
    use: ['style-loader', 'css-loader']
  },

  note: always avoid react to swipe all your node_modules. be as much specific as possible in paths like this one above. 

  note 2: we could also load this style from the css, like that:

    @import '~normalize.css'
    @import '~highlight.js/styles/dracula.css'

  The tilde above means it's inside the node_modules.


  class #100 * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
  Gerar versão de produção:

  Attention: highlightJs latest version (10.0.3) has issues while compiling, outputs an error with UglifyJs. To fix it, I picked the version 9.18.1

  Reason why:
  Features do ES6 tendem a não serem reconhecidas por uma boa parte dos browsers, então a 'build' é necessária para que o Babel converta o nosso código de ES6 para ES5, removendo a sintaxe mais moderna que ainda pode não ser reconhecida por muitos browsers (import, promises, async/await, etc.)
  
  Terminal:
  yarn build

  'dist' folder will handle the new built files.

  Each chunk will have it's own hash, as separeted files. If nothing changes, user will use the cached file. Users will download only the changes. Hashes identify each bundle.

  Webpack may mark some chunks with flags such as 'big', as an alert that you should try to reduce it's sizes.

  "540kb é inaceitável para o tamanho de um bundle" (Daciuk)



  class #101 * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
  Analisando o chunk/bundle de produção

  Terminal:
  yarn add webpack-bundle-analyzer

  webpack/prod.config.js:
  const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer')

  plugins: [
    new BundleAnalyzerPlugin(),
    ...

  So in this case, by looking the analyzer, we see that 'highlight.js' is the heaviest file that should be in another chunk alone.


  class #102 * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
  Estratégias para quebra de chunks

  Edit wepback/prod.config.js:

      new webpack.optimize.CommonsChunkPlugin({
        name: 'react-build',
        chunks: ['main'],
        minChunks: ({ resource }) => (
          /node_modules\/(react(-dom)?|fbjs)\//.test(resource) ||
          /node_modules\/preact(-compat)?\//.test(resource)
        )
      }), // if regex test above returns true, that will be included in the chunk 'main'

      new webpack.optimize.CommonsChunkPlugin({
        name: 'vendor',
        chunks: ['main'],
        minChunks: ({ resource }) => (
          /node_modules/.test(resource)
        )
      }), // if regex test above returns true, that will be included in the chunk 'main'

  It seems that the analyzer may have a bug that messes react itself together with the vendor. But there is a workaround for this issue, by creating extra entry points.

  Edit wepback/common.js:
  At:
    module.exports = {

      // before:
      entry: join(paths.src, 'index')

      // after:
      entry: {
        main: join(paths.src, 'index')
      },

  Then ajust webpack/dev.config.js:

  module.exports = {
  devtool: 'source-map',

    // before:
    entry: [
      common.entry
    ],

    // after:
    entry: [
      common.entry.main
    ],

  Now at webpack/prod.config.js:

  // before:
  new webpack.optimize.CommonsChunkPlugin({
    name: 'react-build',
    minChunks: ({ resource }) => (
      /node_modules\/(react(-dom)?|fbjs)\//.test(resource) ||
      /node_modules\/preact(-compat)?\//.test(resource)
    )
  }),

  new webpack.optimize.CommonsChunkPlugin({
    name: 'vendor',
    minChunks: ({ resource }) => (
      /node_modules/.test(resource)
    )
  }),

  // after:
  new webpack.optimize.CommonsChunkPlugin({
    name: 'react-build',
    chunks: ['main'],
    minChunks: ({ resource }) => (
      /node_modules\/react(-dom)?\//.test(resource) ||
      /node_modules\/preact(-compat)?\//.test(resource)
    )
  }),

  new webpack.optimize.CommonsChunkPlugin({
    name: 'vendor',
    chunks: ['main'],
    minChunks: ({ resource }) => (
      /node_modules/.test(resource)
    )
  }),

  Also moving fbjs, a heavy facebook lib that comes with react:

  // before:
  new webpack.optimize.CommonsChunkPlugin({
    name: 'react-build',
    chunks: ['main'],
    minChunks: ({ resource }) => (
      /node_modules\/react(-dom)?\//.test(resource) ||
      /node_modules\/preact(-compat)?\//.test(resource)
    )
  }),

  // after:
  new webpack.optimize.CommonsChunkPlugin({
    name: 'react-build',
    chunks: ['main'],
    minChunks: ({ resource }) => (
      /node_modules\/(react(-dom)?|fbjs)\//.test(resource) ||
      /node_modules\/preact(-compat)?\//.test(resource)
    )
  }),

  How to control the order that each chunk will be loaded?



  class #103 * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
  Ordering scripts: chunksSortMode

  webpack/prod.config.js:

  Insted of:
  new HtmlPlugin(common.htmlPluginConfig),

  Have this:
  new HtmlPlugin(Object.assign({}, common.htmlPluginConfig, {
    chunksSortMode: (chunk1, chunk2) => {
      const order = ['react-build', 'vendor', 'main']
      const left = order.indexOf(chunk1.names[0])
      const right = order.indexOf(chunk2.names[0])
      return left - right
    }
  })),

  Also, we can minify more the html built:
  minify: { collapseWhitespace: true }

  Like this:
  new HtmlPlugin(Object.assign({}, common.htmlPluginConfig, {
    minify: { collapseWhitespace: true },

    chunksSortMode: (chunk1, chunk2) => {
      const order = ['react-build', 'vendor', 'main']
      const left = order.indexOf(chunk1.names[0])
      const right = order.indexOf(chunk2.names[0])
      return left - right
    }
  })),

  Finally, how to turn off the analyzer from every time we run a build?

  webpack/prod.config.js:

  // before:
  module.exports = {
    plugins:  all stuff here
  }

  // after:
  module.exports = {
    plugins:  [
      all stuff here
    ].concat(
      process.env.ANALYZER ? new BundleAnalyzerPlugin() : []
    ),
  }



  class #104 * * * * * * * * * * * * * * * * * * * * * * * * * * * * *






















      









              




          


      
          








      

















        










