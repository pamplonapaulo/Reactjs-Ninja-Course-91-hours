"React.js Ninja" by Fernando Daciuk

* Module 3 * Part 2


class #50 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Sync requests in Redux
CEP (Post code) Search

https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m03/samples/31-todo-list-get-cep

src/components/search-cep/index.js:

'use strict'

import React from 'react'

const SearchCep = () => (
  <div>
    <form>
      <input type='text' name='cep'/>
      <button type='submit'>Search address</button>
    </form>

    <table>
      <thead>
        <td>Post Code</td>
        <td>Address</td>
        <td>Neighborhood</td>
        <td>City</td>
        <td>State</td>
      </thead>
    </table>

    <tbody>
      <tr>
        <td>2240-000</td>
        <td>Rua das Laranjeiras</td>
        <td>Laranjeiras</td>
        <td>Rio de Janeiro</td>
        <td>RJ</td>
      </tr>
    </tbody>
  </div>
)

export default SearchCep

class #51 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
styles: milligram.io + webpack ajust CSS Loader

  https://milligram.io/

Why? Standard styles for some tags. So we can avoid classes.

    yarn add milligram

src/app.js:

    import 'milligram'

But we get an error when compiling the dev env. Our webpack doesn't include node_module/dist/milligram.css in it's path. let's include it:

webpack/common.js:

        const paths = {
          root: join(__dirname, '..'),
          src: join(__dirname, '..', 'src'),
          dist: join(__dirname, '..', 'dist'),
          modules: join(__dirname, '..', 'node_modules')
        }

        and include 'paths.modules'

          cssLoader: {
            test: /\.css$/,
            include: [paths.src, join(paths.modules, 'milligram')],
            use: ['style-loader', 'css-loader']
          },

Now just one more detail:

      const App = () => (
        <div style={{ display: 'flex', justifyContent: 'space-around', padding: 30 }}>



class #52 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m03/samples/33-todo-list-get-cep

CEP APIs:

1. http://apps.widenet.com.br/busca-cep/api-de-consulta
2. https://viacep.com.br/

Daciuk's own AJAX lib:

    yarn add @fdaciuk/ajax

    import ajax from '@fdaciuk/ajax'


async + componentDidMount

    OBS: Daciuk's ajax's library don't really use promises, but has a familiar interface.

    async componentDidMount () {
      const response = await ajax().get('https://ws.apicep.com/cep.json',Â { code: '22240-000'})
      console.log(response)
    }

    It awaits ajax's response.


class #53 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m03/samples/34-todo-list-get-cep
Get response data and populate the table.

  Let's change the state, so we trigger render.

So the very basic way would be...

src/components/search-cep/search-cep.js: The Cointainer Component

        'use strict'

        import React, { PureComponent } from 'react'
        import SearchCep from './search-cep'
        import ajax from '@fdaciuk/ajax'

        class SearchCepContainer extends PureComponent {
          constructor () {
            super()
            this.state = {
              address: '',
              city: '',
              code: '',
              district: '',
              state: '',
              status: 1
            }
          }

          async componentDidMount () {
            const response = await ajax().get(
              'https://ws.apicep.com/cep.json',
              { code: '22240-000' }
            )
            this.setState(response)
            console.log(response)
          }

          render () {
            return (
              <SearchCep {...this.state} />
            )
          }
        }

        export default SearchCepContainer


src/components/search-cep/index.js: The Presentational Component

        'use strict'

        import React from 'react'

        const SearchCep = ({
          address,
          city,
          code,
          district,
          state,
          status
        }) => (
          <div>
            <form>
              <input type='text' name='cep' />
              <button type='submit'>Search address</button>
            </form>

            <table>
              <thead>
                <tr>
                  <td>Post Code</td>
                  <td>Address</td>
                  <td>Neighborhood</td>
                  <td>City</td>
                  <td>State</td>
                </tr>
              </thead>

              <tbody>
                <tr>
                  <td>{code}</td>
                  <td>{address}</td>
                  <td>{district}</td>
                  <td>{city}</td>
                  <td>{state}</td>
                </tr>
              </tbody>
            </table>

          </div>
        )

        export default SearchCep


That was the very old fashion. Let's improve this code.

Insted of this:

        class SearchCepContainer extends PureComponent {
          constructor () {
            super()
            this.state = {
              address: '',
              city: '',
              code: '',
              district: '',
              state: '',
              status: 1
            }
          }


Now this feature below is already good to use like that, by the time of our module 2 professor told us to not to use, but things change. We don't need anymore the constructor(). Earlier, that could have issues with private methods.

        class SearchCepContainer extends PureComponent {
          state = {
            address: '',
            city: '',
            code: '',
            district: '',
            state: '',
            status: 1
          }

Also there is a new weird sintaxe with '#', which means a private properties: #state
In the past, the sintax used to be: 'private state'.

Now typing 'this#state' means reaching a private state of the class, declared by #state = {}

So now no more constructor () and manually bind(this) methods. We now can use arrow functions (which have lexical scope)

Recap:
before:
          class MyClass extends PureComponent {
            constructor () {
              super()
              this.handleSubmit = this.handleSubmit.bind(this)
            }

            handleSubmit () {
              console.log('submit')
            }
          }
Nowadays:
          class MyClass extends PureComponent {
            handleSubmit = () => {
              console.log('submit')
            }
          }

class #54 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m03/samples/35-todo-list-get-cep

src/components/search-cep/index.js:
          'use strict'

          import React, { PureComponent } from 'react'
          import SearchCep from './search-cep'
          import ajax from '@fdaciuk/ajax'

          class SearchCepContainer extends PureComponent {
            state = {
              address: '',
              city: '',
              code: '',
              district: '',
              state: '',
              status: 1
            }

            handlesubmit = async (e) => {
              e.preventDefault()
              const cep = e.target.cep.value
              const response = await ajax().get(
                'https://ws.apicep.com/cep.json',
                { code: cep }
              )
              this.setState(response)
            }

            render () {
              return (
                <SearchCep {...this.state}
                  handleSubmit={this.handlesubmit}
                />
              )
            }
          }

          export default SearchCepContainer


src/components/search-cep/search-cep.js:
          'use strict'

          import React from 'react'

          const SearchCep = ({
            address,
            city,
            code,
            district,
            state,
            status,
            handleSubmit
          }) => (
            <div>
              <form onSubmit={handleSubmit}>
                <input type='text' name='cep' />
                <button type='submit'>Search address</button>
              </form>

              <table>
                <thead>
                  <tr>
                    <td>Post Code</td>
                    <td>Address</td>
                    <td>Neighborhood</td>
                    <td>City</td>
                    <td>State</td>
                  </tr>
                </thead>

                <tbody>
                  <tr>
                    <td>{code}</td>
                    <td>{address}</td>
                    <td>{district}</td>
                    <td>{city}</td>
                    <td>{state}</td>
                  </tr>
                </tbody>
              </table>

            </div>
          )

          export default SearchCep


OBS:
        In this situation, async comes just before the function itself, not before the method itself:

              handlesubmit = async (e) => {

              }

class #55 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Handling wrong CEP input: displaying a message
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m03/samples/36-todo-list-get-cep

1) Loading results / Is Fetching

  SearchCepContainer:

            state = {
              isFetching: false
            }

            handlesubmit = async (e) => {
              e.preventDefault()
              this.setState({ isFetching: true }) <--
              const code = e.target.cep.value
              const response = await ajax().get(
                'https://ws.apicep.com/cep.json',
                { code }
              )
              this.setState({ isFetching: false }) <--
              console.log(response)
              this.setState(response)
            }

            OBS: If we run this.setState 2 times one after another, React won't do it, it will run just once. So this force us to separe them.

SearchCep:

    <form onSubmit={handleSubmit}>
      <input type='text' name='cep' />
      <button type='submit' disabled={isFetching}>
        {isFetching ? 'Loading...' : 'Search address'}
      </button>
    </form>

    Also, if status equals 1, shows table. If not, shows message:

        {status === 400 && <div>Post Code not found</div>}

        {status === 200 &&  (
          <table>
            <thead>
              <tr>
                <td>Post Code</td>
                <td>Address</td>
                <td>Neighborhood</td>
                <td>City</td>
                <td>State</td>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>{code}</td>
                <td>{address}</td>
                <td>{district}</td>
                <td>{city}</td>
                <td>{state}</td>
              </tr>
            </tbody>
          </table>
        )}

class #56 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
With Reducer
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m03/samples/37-todo-list-get-cep

src/components/search-cep/index.js
src/components/search-cep/search-cep.js

redux-flow/reducers/address/index.js:
        'use strict'

        import createReducer from '../create-reducer'
        import { UPDATE_ADDRESS } from './actions'

        const initialState = {
          address: '',
          city: '',
          code: '',
          district: '',
          state: '',
          status: 1
        }

        const address = createReducer(initialState, {
          [UPDATE_ADDRESS]: (state, action) => action.payload
        })

        export default address



redux-flow/reducers/address/address.test.js:
        'use strict'

        import { expect } from 'chai'
        import deepFreeze from 'deep-freeze'
        import address from './index'
        import { UPDATE_ADDRESS } from './actions'

        it('address should be a function', () => {
          expect(address).to.be.a('function')
        })

        it('should action UPDATE_ADDRESS update address', () => {
          const before = deepFreeze({
            address: '',
            city: '',
            code: '',
            district: '',
            state: '',
            status: 1
          })

          const action = deepFreeze({
            type: [UPDATE_ADDRESS],
            payload: {
              address: 'Rua das Laranjeiras - atÃ© 146',
              city: 'Rio de Janeiro',
              code: '22240-000',
              district: 'Laranjeiras',
              state: 'RJ',
              status: 1
            }
          })

          const after = {
            address: 'Rua das Laranjeiras - atÃ© 146',
            city: 'Rio de Janeiro',
            code: '22240-000',
            district: 'Laranjeiras',
            state: 'RJ',
            status: 1
          }

          expect(address(before, action)).to.be.deep.equal(after)
        })


redux-flow/reducers/address/actions.js:
        'use strict'

        export const UPDATE_ADDRESS = 'address:UPDATE_ADDRESS'

class #57 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Unit tests
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m03/samples/38-todo-list-get-cep





First of all, professor actually removed some of the previous tests in our code. Those removed were these ones here:

        address.test.js / visibility-filter.test.js / todos.test.js:

        it('address should be a function', () => {
          expect(address).to.be.a('function')
        })

        In each test file, this test checks if the reducer is a function, but create-reducer is a function, that's what is actually being covered by this test.

The same redundance in coverage we find in another test inside 2 of these files: 'action is unknown'

        visibility-filter.test.js / todos.test.js:

        it('Should return the latest state when action is unknown', () => {
          const before = deepFreeze([{ id: 0, text: 'Hey', completed: false }])
          const action = deepFreeze({ type: 'ANYTHING'})
          const after = [{ id: 0, text: 'Hey', completed: false }]
          expect(todos(before, action)).to.be.deep.equal(after)
        })

        it('Should return latest state when action is unknown', () => {
          const before = SHOW_COMPLETED
          const action = deepFreeze({
            type: 'UNKNOWN',
            payload: { filter: SHOW_ALL}
          })
          const after = SHOW_COMPLETED
          expect(visibilityFilter(before, action)).to.be.equal(after)
        })

and here as well: 'state is undefined'

        visibility-filter.test.js / todos.test.js:

        it('Should return initialState when latest state is undefined', () => {
          const before = undefined
          const action = deepFreeze({})
          const after = initialState
          expect(visibilityFilter(before, action)).to.be.equal(after)
        })

        it('Should return initialState when state before is undefined', () => {
          const before = undefined
          const action = deepFreeze({})
          const after = initialState
          expect(todos(before, action)).to.be.deep.equal(after)
        })

Now finally we lost some coverage! Look at the coverage on the test:

----------------------------|----------|----------|----------|----------|-------------------|
File                        |  % Stmts | % Branch |  % Funcs |  % Lines | Uncovered Line #s |
----------------------------|----------|----------|----------|----------|-------------------|
All files                   |      100 |       60 |      100 |      100 |                   |
 reducers                   |      100 |    33.33 |      100 |      100 |                   |
  create-reducer.js         |      100 |    33.33 |      100 |      100 |               4,5 |
 reducers/address           |      100 |      100 |      100 |      100 |                   |
  actions.js                |      100 |      100 |      100 |      100 |                   |
  index.js                  |      100 |      100 |      100 |      100 |                   |
 reducers/todos             |      100 |      100 |      100 |      100 |                   |
  actions.js                |      100 |      100 |      100 |      100 |                   |
  index.js                  |      100 |      100 |      100 |      100 |                   |
 reducers/visibility-filter |      100 |      100 |      100 |      100 |                   |
  actions.js                |      100 |      100 |      100 |      100 |                   |
  index.js                  |      100 |      100 |      100 |      100 |                   |
----------------------------|----------|----------|----------|----------|-------------------|

What is Daciuk actually doing? We are about to write the tests directly to the 'create-reducer' function, which is the real source of all that trash we just removed. Got it?

But before we move on...

A breif look into the 'coverage' folder:

        coverage/lcov-report: index.html

        It shows our coverage. If you click the red-not-coverage flagged part... Boom! You get exactly what part of the code is not coverage. In this specific case, here is what is being showed and means we still have to cover:

                const createReducer = (initialState, handleActions) =>
                  (state = initialState, action) =>
                    handleActions.hasOwnProperty(action.type)
                      ? handleActions[action.type](state, action)
                      : state
                
                export default createReducer


        OBS:
        1. Yellow highlighted 'initialState' and 'state'
        2. If you mouse hover those highlights, it says:
                'branch not covered'

class #58 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
create-reducer.test

Still on:
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m03/samples/38-todo-list-get-cep

src/redux-flow/reducers/create-reducer.test.js:

          'use strict'

          import { expect } from 'chai'
          import deepFreeze from 'deep-freeze'
          import createReducer from './create-reducer'

          const initialState = 0
          const reducer = createReducer(0, {
            'INCREMENT': (state, action) => state + 1,
            'DECREMENT': (state, action) => state - 1
          })

          it('createReducer should be a function', () => {
            expect(createReducer).to.be.a('function')
          })

          it('createReducer(initialState, {}) should return a function', () => {
            expect(createReducer([], {})).to.be.a('function')
          })

          it('should create a reducer', () => {
            const before = 0
            const action = { type: 'INCREMENT' }
            const after = 1

            expect(reducer(before, action)).to.be.equal(after)
          })

          it('reducer should return latest state if action is unknown', () => {
            const before = 3
            const action = deepFreeze({ type: 'UNKNOWN' })
            const after = 3
            expect(reducer(before, action)).to.be.equal(after)
          })

          it('reducer should return initialState when latest state is undefined', () => {
            const before = undefined
            const action = deepFreeze({})
            const after = initialState
            expect(reducer(before, action)).to.be.equal(after)
          })



OBS: We are not using 'deep.equal' cuz we are passing primitive values, not arrays or objects.

Also we include this in the test:

          it('initialState should not be undefined', () => {
            try {
              createReducer()
            } catch (e) {
              expect(e.message).to.be.equal('initialState should not be undefined')
            }
          })

But to get this working, we should include a condition in the create-reducer.js:

            if (typeof initialState === 'undefined') {
              throw new Error('initialState should not be undefined')
            }

Also, in case the second argument is missing, test should have:

            it('handleActions should not be different from object', () => {
              try {
                createReducer([])
              } catch (e) {
                expect(e.message).to.be.equal('createReducer expects the second argument as an object representing reducer')
              }
            })

Then the create-reducer.js must have this too:

            if (Object.prototype.toString.call(handleActions) !== '[object Object]') {    
              throw new Error('createReducer expects the second argument as an object representing reducer')
            }

That said, the create-reducer.js by the end would look like this:

          const createReducer = (initialState, handleActions) => {
            if (typeof initialState === 'undefined') {
              throw new Error('initialState should not be undefined')
            }

            if (Object.prototype.toString.call(handleActions) !== '[object Object]') {    
              throw new Error('createReducer expects the second argument as an object representing reducer')
            }

            return (state = initialState, action) =>
              handleActions.hasOwnProperty(action.type)
                ? handleActions[action.type](state, action)
                : state
          }

class #59 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Putting together the 2 apps: combining address with the todos list

src/redux-flow/reducers/index.js: this file centers/combines all reducers

      import { combineReducers } from 'redux'
      import address from './address'
      import todos from './todos'
      import visibilityFilter from './visibility-filter'

      export default combineReducers({
        address,
        todos,
        visibilityFilter
      })

src/redux-flow/reducers/address/action-creators.js:

      import { UPDATE_ADDRESS } from './actions'

      export const updateAdress = (data) => ({
        type: UPDATE_ADDRESS,
        payload: data
      })

src/components/search-cep/index.js:

      Include imports:

        import { connect } from 'react-redux'
        import { updateAddress } from 'reducers/address/action-creators'


      Pass response from CEP api:

        this.props.dispatch(updateAddress(response)) 

      Pass it to child component: this.props.address

        <SearchCep
          {...this.state}
          {...this.props.address}
          handleSubmit={this.handlesubmit}
        />

      Export everything with connect, using mapStateToProps:

        const mapStateToProps = (state) => ({
          address: state.address
        })

        export default connect(mapStateToProps)(SearchCepContainer)

      

class #60 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Dispatch being passed as props

https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m03/samples/40-todo-list-get-cep

src/components/search-cep/index.js:

        this.props.dispatch(response)

        const mapDispatchToProps = (dispatch) => ({
          updateAddress: (data) => dispatch(updateAddress(data))
        })

        export default connect(mapStateToProps, mapDispatchToProps)(SearchCepContainer)

Now component itself doesn't have dependencies with Redux.

This mapDispatchToProps function could be written in a shorter way, because the property has the same signature as it's correlative action-creator:

address/action-creators.js:

  export const updateAddress = (data) => ({
    type: UPDATE_ADDRESS,
    payload: data
  })

mapDispatchToProps:

  const mapDispatchToProps = (dispatch) => ({
    updateAddress: (data) => dispatch(updateAddress(data))
  })

Could be just like that:

const mapDispatchToProps = (dispatch) => ({
  updateAddress: updateAddress
})

And since property and it's value have the same name, we can also use:

const mapDispatchToProps = (dispatch) => { updateAddress }


class #61 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
The application's initialState

https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m03/samples/41-todo-list-get-cep

src/index.js:

        const store = createStore(reducer)
        const renderState = () => {
          console.log('state:', store.getState())
        }

So given a situation where a user just logged in our application.

How to get his initial data?

createStore's second parameter!

        import { createStore } from 'redux'

        const initialState = {
          todos: [{
            text: 'auto',
            id: '123',
            completed: true
          }],

        address: {
            address: 'Rua Jorge Barbieri',
            city: 'SÃ£o Paulo',
            state: 'SP',
            code: '55555-000',
            district: 'Perdizes',
            status: 200
          }
        }

        const store = createStore(reducer, initialState)

We don't have to pass all keys, buy the ones we pass must have the same signature that expected by our components.

class #62 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
replaceReducar & reducer's hot reload

https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m03/samples/42-todo-list-get-cep

It keeps the previous state when you update any reducer.

It's a way to implement hot reloaders beyong the components, including the reducers.

src/index.js:

        if (module.hot) {
          module.hot.accept('./app', () => {
            const NextApp = require('./app').default
            renderApp(NextApp)
          })

          // here:

          module.hot.accept('reducers', () => {
            const nextReducers = require('reducers').default
            store.replaceReducer(nextReducers)
          })
        }

          // and notive that 'reducers' it's being required just like we imported in the top of this file:

          import reducer from 'reducers'

        How to check this working?
        src/redux-flow/reducers/todos/index.js:

          [ADD_TODO]: (state, action) => state.concat({
            id: action.payload.id,
            text: action.payload.text,
            completed: false
          }),

          Replace the 'text' property above by:

            text: action.payload.text + ' FLAG TEST',

          Then without restart the page, if the user inserts another item in the todos list, then it comes with the extra string ' FLAG TEST' we just included in the code.

          
class #63 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
middlewares in redux

https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m03/samples/43-todo-list-get-cep























class #64 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #65 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #66 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #67 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #68 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #69 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #70 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
















class #71 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #72 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #73 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #74 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #75 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #76 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #77 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #78 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #79 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

class #80 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #81 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #82 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #83 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #84 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #85 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #86 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #87 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #88 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #89 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

class #90 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #91 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #92 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #93 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #94 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
