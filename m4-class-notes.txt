"React.js Ninja" by Fernando Daciuk

* Module 4 * React Router

https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04

Part 1

class #001 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Presentation and Module requirements

class #002 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

React Router
http://reacttraining.com/react-router

- Web (React.js)   <-- 
- Native (React Native)

https://reacttraining.com/react-router/web/guides/quick-start

Terminal:
yarn add react-router-dom

https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/01-hello-react-router/01


In case you face problems such as upath@^1.1.1 in our yarn.lock, you may want to run yarn install with:

        --ignore-engines

class #003 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Browser Router

-> Creation of Single Page Applications (SPA)

        import { BrowserRouter } from 'react-router-dom'

        const App = () => (
          <BrowserRouter>
            <div>
              <h1>Hello</h1>
            </div>
          </BrowserRouter>
        )

Component <Link>:

        import { Link } from 'react-router-dom'

        <Link to='/about' children='About' />

        Or

        <Link to='/about'>About</Link>


    Different than an html <a> tag, this React <Link> component doesn't reload the entire page. It's kind of like <Link> comes with a preventDefault() by itself.

    Props:

      1. path=<strin>
      2. path=<ReactComponent>



Component <Route>:

        import { Route } from 'react-router-dom'

        <Route path='/about' component={About} />

        const About = () => (
          <h1>About</h1>
        )

        Behind the scenes, <Route> does something more or less like a short circuit:

          {this.state.route === '/about' && <About />}


class #004 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Rendering more than one route
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/01-hello-react-router/02

'exact' & Home trick render:

  <Route path='/' component={Home} />

  path='/'
  Will get rendered any time another route with '/' is rendered, such as:
  path='/about' or path='/contact'

  If you want {Home} to get render only at it's exact route, you must include the exact property:

      <Route path='/' exact component={Home} />

class #005 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Webpack: fixing issue
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/01-hello-react-router/03

Issue it's about relative paths X absolute paths

webpack/dev.congif.js: 

  output -> publicPath

  PublicPath is the path where webpack generates memory assets. What Daciuk did in the class was just the add of a forward slash: '/'

  Before:

          output: Object.assign({}, common.output, {
            filename: '[name].js',
            publicPath: ''
          }),

  After:

          output: Object.assign({}, common.output, {
            filename: '[name].js',
            publicPath: '/'
          }),

  But! My webpack/dev.config didn't have neigther '' nor '/'. It didn't have any publicPath at all. And it worked. Probably Daciuk also updated this boilerplate (here used by me) later, before I started the course.

          output: Object.assign({}, common.output, {
            filename: '[name].js'
          }),

  Ok, end of the mistery: Daciuk actually moved it to webpack/common.js:

          output: {
            path: paths.dist,
            filename: '[name]-[chunkhash].js',
 -->        publicPath: '/'
          },

class #006 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Dynamic Routes
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/01-hello-react-router/04

BrowserRouter can't have many children. It should have just one child:

        <BrowserRouter>
          <div>

          </div>
        </BrowserRouter>

Routes' props:
history: {…}, location: {…}, match: {…}



console.log(props.match)

        isExact: true
        params: {}
        path: "/blog/post-2"
        url: "/blog/post-2"

So insted of:

    <Route path='/blog/post-1' component={Post} />
    <Route path='/blog/post-2' component={Post} />

Dynamicaly we could write:

    <Route path='/blog/:post' component={Post} />

That way, the Route has params filled:

    params:
    post: "post-2"

    or

    params:
    post: "post-1"



After all, the blog area would look like this:

        const Blog = () => (

        <div>
          <h1>Blog</h1>
          <ul>
            <li><Link to='/blog/Jesus'>Post about Jesus's life</Link></li>
            <li><Link to='/blog/Sidarta'>Post about Sidarta's life</Link></li>
          </ul>

          <Route path='/blog/:post' component={Post} />
          <Route exact path='/blog' component={NoPost} />
        </div>
      )

      const Post = ({ match }) => (
        <div>
          <h2>Post: {match.params.post}</h2>
        </div>
      )

      const NoPost = () => (
        <div>
          <p>Select a post</p>
        </div>
      )

class #007 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
SPA Concepts | Route request
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/02-spa-concepts/01

- Route request behind the scenes

Set up a static server:

    mkdir m4-01-server
    cd m4-01-server
    echo "{}" >> package.json
    npm i --save-dev http-server

Now edit package.json to include a script:

    before:
    {
      "devDependencies": {
        "http-server": "^0.12.3"
      }
    }

    then add:
    {
      "scripts": {
        "start": "http-server"
      },
      "devDependencies": {
        "http-server": "^0.12.3"
      }
    }

Run the server:

    yarn start

Then:

yarn run v1.21.1
warning package.json: No license field
$ http-server
Starting up http-server, serving ./
Available on:
  http://127.0.0.1:8080
  http://192.168.0.199:8080
Hit CTRL-C to stop the server


We did this cuz professor wanted to show that an index.html file opened from this URL (generated by the server) actually loads the file in a request type 'get'. If you just open the index.html file directly by opening the file in the browser, then there is nothing actually being loadded. We can check this difference by dev tools in "network" tab, where file size shows some value (421 bites) in a request and shows zero if opened directly by the browser as a local file.

Static server provides routes in a totally different way. Paths using '/' in the URL mean real/physic folders in it's hard disk. Dynamic servers can handle it in dynamic ways, which is what we are doing by React Routes.


class #008 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
History API (browser history, a HTML5 feature)
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/02-spa-concepts/02

Navigation in a front-end application

history API is stored inside window object:

      window.history

method: PUSH STATE

        history.pushState()
        It includes in the history a given URL.

        function handleClick (e) {
          e.preventDefault()
          var state = {}
          var title = ''
          var url = e.target.getAttribute('href')
          history.pushState(state, title, url)
          $h1.textContent = url
        }

Full code:
https://github.com/da2k/curso-reactjs-ninja/blob/master/examples/m04/02-spa-concepts/02/main.js

By this approach, navigation occurs without load the entire page.

that's it. Just a demonstrarion.

class #009 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
History API
method: ON POP STATE
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/02-spa-concepts/03


      window.onpopstate = function (e) {
        console.log('state:', e.state)
        navigation({ url: e.state.url })
      }

      Method onpopstate happens when user clicks in the backwards or forwards buttons in the browser.

      e.state.url gives you the path in the browser, the URL.

Full code:
https://github.com/da2k/curso-reactjs-ninja/blob/master/examples/m04/02-spa-concepts/03/main.js


class #010 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
History API:
method: REPLACE STATE

https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/02-spa-concepts/04

Last class, by navigating back and forth in the browser, we get state null when we get back to the starting page/home, because the first state of the application was not defined.

We could just push a initial state when users access the page. But using method 
replaceState that works better.

history.replaceState({ url: '/' }, '', '/')


class #011 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Reload issue

https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/02-spa-concepts/05

This issue have to be solved in the server side, on the back-end.

Any kind of request or route inside the domain, must get redirect to the application's initial page.

Terminal:
yarn add --dev serve

This dependency is basicaly already set to work that way.
https://www.npmjs.com/package/serve

script in package.json:

          {
            "scripts": {
              "start": "serve"
            },
            "devDependencies": {
              "http-server": "^0.12.3",
              "serve": "^11.3.2"
            }
          }


serve -s

          {
            "scripts": {
              "start": "serve -s"
            },
            "devDependencies": {
              "http-server": "^0.12.3",
              "serve": "^11.3.2"
            }
          }

What it does? Any route not found will get redirected to home.

That's it. That's the solution. Course won't dive deeper into this.


class #012 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
React Router: Switch component
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/03-hello-react-router

<Switch /> renders a single route per time.

    import { Switch } from 'react-router-dom'

    <Switch>
      <Route path='/' exact component={Home} />
      <Route path='/about' component={About} />
      <Route path='/blog' component={Blog} />
      <Route component={Error404} />
    </Switch>

const Error404 = () => (
  <h1>Page not found</h1>
)

Route without path would get loaded if not wrapped by <Switch/>

Important to have the error404 at the end, so it gets loaded only if anyone else matches the path.

Without the Switch, this code would load the error404 for all of them.


class #013 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Dynamic / Specific Routes

https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/03-hello-react-router/02




<Route path='/about' component={Page} />
<Route path='/contact' component={Page} />

const Page = ({ match }) => (
  <div>
    {console.log({match})}
    <h1>{Page}</h1>
  </div>
)

But the magic is, insted of:

      <Switch>
        <Route path='/' exact component={Home} />
        <Route path='/about' component={Page} />
        <Route path='/contact' component={Page} />
        <Route path='/blog' component={Blog} />
        <Route component={Error404} />
      </Switch>

How about that: path='/(about|contact)'

      <Switch>
        <Route path='/' exact component={Home} />
        <Route path='/(about|contact)' component={Page} />
        <Route path='/blog' component={Blog} />
        <Route component={Error404} />
      </Switch>


Also. With that current code:

      const Blog = () => (

        <div>
          <h1>Blog</h1>
          <ul>
            <li><Link to='/blog/Jesus'>Post about Jesus's life</Link></li>
            <li><Link to='/blog/Sidarta'>Post about Sidarta's life</Link></li>
          </ul>

          <Route path='/blog/:post' component={Post} />
          <Route exact path='/blog' component={NoPost} />
        </div>
      )

      A URL request with extra characteres would also get loaded:

      http://localhost:3000/blog/JesusDead

      Renders: Post:
      
          JesusDead

      Shit, we've better fix that!

          const Blog = () => (

            <div>
              <h1>Blog</h1>
              <ul>
                <li><Link to='/blog/Jesus'>Post about Jesus's life</Link></li>
                <li><Link to='/blog/Sidarta'>Post about Sidarta's life</Link></li>
              </ul>

              <Route path='/blog/:post(Jesus|Sidarta)' component={Post} />
              <Route exact path='/blog' component={NoPost} />
            </div>
          )

      So with this approach, any extra type in the URL request won't render anything. 

      To achieve something a little better, let's include Switch like we saw earlier:

                const Blog = () => (

                  <div>
                    <h1>Blog</h1>
                    <ul>
                      <li><Link to='/blog/Jesus'>Post about Jesus's life</Link></li>
                      <li><Link to='/blog/Sidarta'>Post about Sidarta's life</Link></li>
                    </ul>

                    <Switch>
                      <Route exact path='/blog' component={NoPost} />
                      <Route path='/blog/:post(Jesus|Sidarta)' component={Post} />
                      <Route component={Post404} />
                    </Switch>
                  </div>
                )

                const Post404 = () => (
                  <h1>This post doesn't exist</h1>
                )

      Super important to remember this is RegEx being passed in the path.
      
      Check this one and try it out at the browser:

                const Blog = () => (
                  <div>
                    <h1>Blog</h1>
                    <ul>
                      <li><Link to='/blog/post-1'>Post 1</Link></li>
                      <li><Link to='/blog/post-2'>Post 2</Link></li>
                      <li><Link to='/blog/post-3'>Post 3</Link></li>
                      <li><Link to='/blog/post-4'>Post 4</Link></li>
                    </ul>

                    <Switch>
                      <Route exact path='/blog' component={NoPost} />
                      <Route path='/blog/:post(post-[1234])' component={Post} />
                      <Route component={Post404} />
                    </Switch>
                  </div>
                )

      As you see, we could use RegEx in deep.


class #014 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
NavLink
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/03-hello-react-router/03

import { NavLink } from 'react-router-dom'

Works pretty much just like <Link>, with one difference:

  - it adds a class 'active' in the clicked NavLink
  - it turns a property 'aria-current' into true if the NavLink was clicked, or false if it's not active.

NavLink checks if the 'to=' property matches the current route.
If the current route at the URL contains the route in 'to'. That means a route like home, '/', would be contained inside every other route. How to prevent this? Using the same prop we use in the Route: exact

    <li><NavLink to='/' exact children='Home' /></li>

OBS: Differently from prof's app, my App actually shows 'aria-current=page' for those selected NavLinks.

Insted of having 'active' class, if you will, we could have another value for that class. Just pass this property:

    activeClassName='active-link'

    With that, it will start to use this custom name for the active NavLink in this single item where you passed it. If you want that name in all options, pass it in all of them.

    <ul>
      <li><NavLink activeClassName='active-link' to='/blog/post-1'>Post 1</NavLink></li>
      <li><NavLink activeClassName='active-link' to='/blog/post-2'>Post 2</NavLink></li>
      <li><NavLink activeClassName='active-link' to='/blog/post-3'>Post 3</NavLink></li>
      <li><NavLink activeClassName='active-link' to='/blog/post-4'>Post 4</NavLink></li>
    </ul>

Inline Style for Active NavLink:

  activeStyle={{ color: 'red' }}

  <ul>
    <li><NavLink activeStyle={{ color: 'red' }} to='/' exact children='Home' /></li>
    <li><NavLink activeStyle={{ color: 'red' }} to='/about' children='About' /></li>
    <li><NavLink activeStyle={{ color: 'red' }} to='/contact' children='Contact' /></li>
    <li><NavLink activeStyle={{ color: 'red' }} to='/blog' children='Blog' /></li>
  </ul>


  Also, in the real world we wouldn't write like this. We would have an component for that:

          const Link = (props) => (
            <NavLink activeStyle={{ color: 'red' }} {...props} />
          )


          <ul>
            <li><Link to='/' exact>Home</Link></li>
            <li><Link to='/about'>About</Link></li>
            <li><Link to='/contact'>Contact</Link></li>
            <li><Link to='/blog'>Blog</Link></li>
          </ul>

class #015 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Prop Render
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/03-hello-react-router/04

Route: path + component

If Route doesn't come with path, component will always get rendered, unless if inside a Switch.

So far, we have been using component= to render.

Why do we need prop Render?

1. If you have an prop in scope that must be passed down.

Ex:

        const NoPost = ({ numberOfPosts }) => (
          <div>
            <p>Select one of the {numberOfPosts} post</p>
          </div>
        )

        For that, we can't just have a Route like this:
        <Route exact path='/blog' component={NoPost} />

        So how can we do? This way:
        <Route exact path='/blog' render={() => <NoPost numberOfPosts={2} />} />

        Prop component= could achieve something close, but with different things going on behind the scene and different results.

              <Route exact path='/blog' component={() => <NoPost numberOfPosts={2} />} />

        That line above "works", but we don't want it. Why?

        Prop render= holds the data in cache and uses when it needs. React Router calls this function when necessary, after have read it and saved in cache.

        Prop component= expect a React component. The function passed in the component would be created every single time when the component is called. So the whole component would have mountings and unmountings not desired. So prop render= optimizes the whole thing.

        So prop render= is great every time we need to pass data to the component, when we can't pass by reference.

         Also, this prop render renders basic JSX, doesn't have to be an etire component. It could be just this:

          <Route exact path='/blog' render={() => <p>Select a post</p>} />

        Also, those props from component= prop, that we saw before, such as 'match', 'location', and 'history'; they are also available when we use render= prop. Like that:

              <Route exact path='/blog' render={(props) => <NoPost numberOfPosts={2} {...props} />} />

              const NoPost = ({ numberOfPosts, match, history, location }) => (
                <div>
                  <p>Select one of the {numberOfPosts} post</p>
                </div>
              )

class #016 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Children prop
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/03-hello-react-router/05


Children as a funtion inside Route component will always get rendered, even without match with path.

Children also receives all props that other components get: match, location, history...

BUT! Those properties are available only when there is a match on the path.

  <Route path='/about'>
    {({ match }) => (
      <pre>
        {console.log('About Page', match)}
        This is About page.
      </pre>
    )}
  </Route>

In this code above, match prop is null unless path has a match.
However, the text 'This is About page.' renders all the time, no matter the path.

So based on the match, our code may take different decisions.

      <Route path='/about'>
        {({ match }) => (
          <pre>
            Is this ABOUT's page? {`${!!match}`}
          </pre>
        )}
      </Route>


Another example:

      const Link = (props) => (
        <Route path={props.to} exact={props.exact}>
          {({ match, history }) => (
            <a
              href={props.to}
              style={match ? { color: 'red' } : null}
              onClick={(e) => {
                e.preventDefault()
                history.push(props.to)
              }}
            >
              {props.children}
            </a>
          )}
        </Route>
      )

      OBS: This is kind of how NavLink works behind the scenes.

class #017 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Pattern "Render Props"

Earlier, we saw the pattern Container Components (Parent) & Presentational Components (Children).

So what is Pattern Render Props?

It's how the Route component works, the way we started to talk about those last few classes.

Route -> prop Children, used as a function

  <Route path={props.to} exact={props.exact}>

                    {({ match, history }) => (
                      <a
                        href={props.to}
                        style={match ? { color: 'red' } : null}
                        onClick={(e) => {
                          e.preventDefault()
                          history.push(props.to)
                        }}
                      >
                        {props.children}
                      </a>
                    )}

  </Route>

  It was known as "children as a function'. Nowadays, it got named as "Render Props".

  It's ok to mix those patterns, you don't have to chose just one.

class #018 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Route props: match
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/03-hello-react-router/06

3 ways to render a component:

  
  - using component
  <Route component={} />
  
  - using render
  <Route render={} />
  
  - using children
  <Route>{() => (<a>{props.children}</a>)}</Route>

Important to mention that we cannot use all at once. Pick one!


match.params:

  <Route path='/(about|contact)' component={Page} />  

        http://localhost:3000/about
          console.log(match.params):
            params: {0: "about"}

  <Route path='/(about|contact)/(1|2)?' component={Page} />

        http://localhost:3000/about
          console.log(match.params):
            params: {0: "about", 1: undefined}
  
        http://localhost:3000/about/1
          console.log(match.params):
            params: {0: "about", 1: "1"}

        http://localhost:3000/about/2
          console.log(match.params):
            params: {0: "about", 1: "2"}


  As shown abovem, using a question mark '?' at the end of your params, you set those as optionals.

    path='/(about|contact)/(1|2)?'

        Above, (about|contact) is not an option
        But (1|2) is an option

    path='/(about|contact)?/(1|2)?'

        Both params are options.

    path='/(about|contact)/:id?'

        http://localhost:3000/about/2
        params: {0: "about", id: "2"}

        http://localhost:3000/about/
        params: {0: "about", id: undefined}

    path='/(about|contact)/:id'

        http://localhost:3000/about/
        Page not found

    Sub routes: Blog

    When a component doesn't have a path, such as:

          <Route component={Post404} />
    
    properties (or the 'match' object if you will) passed throw it actually are the same reference from it's parent, which in 'Post404' case, is 'Blog':

          <Route path='/blog' component={Blog} />


class #019 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Route Props: location (pathname & key)
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/03-hello-react-router/07

  {
    hash: ""
    key: "ozfnyj"
    pathname: "/about"
    search: ""
    state: undefined
  }

  --> location's data (above) is based on the current route. 

  --> match's data (last class) is based on the current match (route and component).

    hash:
    key:
    pathname:
    search:
    state:

    pathname: which route got the match

      If URL is like: http://localhost:3000/blog/post-1

        Both Blog component and Post component show the same pathname:
        
              pathname: "/blog/post-1"


    key: identifies each route of navigation, like an Id

      Also, if URL is like: http://localhost:3000/blog/post-1

        Both Blog component and Post component show the same key (which is ramdom and changes every time):
          
              key: "ai4qty"

        Key prop is available only when navigation itself starts. Before that, location's object won't show it to you. So home pages mostly won't have a key. It helps to know if user is in the first page of history.

        Every navigation will keep the key. Keys have different value when another routes get trigged. visiting those routes again will show you the previous value of that related key.


class #020 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Route Props: location (hash)
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/03-hello-react-router/08


Identifies if URL contains any hash (#)

Helps scroll navigation in the same page, jumping to another part of the page.

      <li><a href='#site-info'>Site information</a></li>

      <div id='site-info' style={{ margin: '1000px 0' }}>
        <h2>Site information</h2>
      </div>

{hash: "#site-info"}

class #021 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Route Props: location (search)
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/03-hello-react-router/09

home -> { search: ""}

It apsses data via query string, in URLs

How to use?

Just include your data after a question mark

http://localhost:3000/about?data=my-data

  {
    pathname: "/about",
    search: "?data=my-data",
    hash: "",
    state: undefined
  }

http://localhost:3000/about?name=paulo&age=41

  { search: "?name=paulo&age=41" }


http://localhost:3000/?name=paulo&age=41&city=London&field=frontend

      const Home = ({ match, location }) => (
        <div>
          {console.log('HOME location:', location)}
          {console.log(
            'Location Search:',
            location.search
              .replace('?', '')
              .split('&')
          )}
          <h1>Home</h1>
        </div>
      )

      console:

        ["name=paulo", "age=41", "city=London", "field=frontend"]

      From array to object:

        {console.log(
          'Location Search:',
          location.search
            .replace('?', '')
            .split('&')
            .reduce((acc, item) => {
              const [key, value] = item.split('=')
              acc[key] = value
              return acc
            }, {})
        )}

        console:
          {
            name: "paulo",
            age: "41",
            city: "London",
            field: "frontend"
          }

How about duplicated keys?

http://localhost:3000/?name=paulo&age=41&city=London&field=frontend&arr=0&arr=1

To avoid overriding an existent key, let's change the reduce's content in the code above:

        .reduce((acc, item) => {
          const [key, value] = item.split('=')
          if (acc[key]) {
            acc[key] = [acc[key]].concat(value)
          } else {
            acc[key] = value
          }
          return acc
        }, {})

        It returns:

          {
            age: "41"
            arr: ["0", "1"]
            city: "London"
            field: "frontend"
            name: "paulo"
          }

Some complex manipulation might get too tricky, so there is a lib to help us on that.

https://www.npmjs.com/package/query-string


class #022 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Route Props: location (state)
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/03-hello-react-router/10

  {
    pathname: "/about",
    search: "?data=my-data",
    hash: "",
    state: undefined
  }

So far, all our pages show state undefined.

Reminder: location's object is created based on the current route.

The property 'to=' can handle all location properties:

    pathname
    search
    hash
    state

      <li><Link to={{
        pathname: '/',
        hash: '#site-info',
        state: { id: 'home' },
        search: '?name=daciuk'
      }} exact>Home</Link></li>


All of them could also be passed via URL, except the state!

http://localhost:3000/?name=paulo&age=41&city=London&field=frontend&arr=0&arr=1#site-info

Browser keeps the 'state' in it's memory. Since the URl itself doesn't bring states, it work only when user clicks the Link or NavLink

class #023 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Route Props: history.length
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/03-hello-react-router/11


      const Home = ({ match, location, history }) => (
        <div>
          {console.log('HOME location:', location)}
          {console.log('HOME history:', history)}
          <h1>Home</h1>
        </div>
      )

  prop location X history.location

  They are the same thing. But history is mutable, it gets updates evey new navigation. But reference is the same. If you have to check a route change, check by prop location. That way you make sure you are checking the most updated data.

  history.length:

    how many pages you have in your navigation history. but it doesn't count repeated pages, counts for each new page on the navigation.


class #024 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Route Props: history.push
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/03-hello-react-router/12


Pushes new data to history. Just like <Link> or <NavLink> do.

    const Link = (props) => (
      <Route path={props.to} exact={props.exact}>
        {({ match, history }) => (
          <a href={props.to} onClick={(e) => {
              e.preventDefault()
              history.push(props.to)
            }}
          >{props.children}</a>
        )}
      </Route>
    )

also:

  <li><Link to={{ pathname: '/', state: { link: 'home' } }} exact>Home</Link></li>

also second optional argument: state

  history.push(props.to, { link: 'Link' })

Most used when a navigation must get done but for some reason we can't use Link or NavLink.

class #025 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Route Props: history.replace
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/03-hello-react-router/13


Despite pushing extra data to history, it replaces the current page with the data you are passing.

It's very useful when we want to make sure the user won't navigate back, the navigation by our components will be working without include extra pages in the history, but always overriding the same previous page, the existent history.


class #026 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Route Props: history.action
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/03-hello-react-router/14

Actions: it's the action of what is happening in the navidation

  "POP" (First page load or nav by browser's button 'back' and 'forward')
  "PUSH" (Adds a new data in the history)
  "REPLACE" (Replaces the current route in history)

So we can know how user is doing the navigation.

class #027 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Route Props: history.goBack()
Route Props: history.goForward()
Route Props: history.go()
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/03-hello-react-router/15


OBS:
  - It considers the order in the history.
  - The action is "POP"

          <ul>
            <li>
              <Route>
                {({ history }) => (
                  <button onClick={(e) => history.goBack()}>{'<-'} Voltar</button>
                )}
              </Route>
            </li>

            <li>
              <Route>
                {({ history }) => (
                  <button onClick={(e) => history.goForward()}>Próxima página {'->'}</button>
                )}
              </Route>
            </li>

          </ul>

history.go()

history.go(-1), same as history.goBack()
history.go(1), same as history.goForward()

But it could be:
history.go(-2), same as history.goBack() * 2

And so on.

class #028 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
<Redirect />
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/03-hello-react-router/16

import { Redirect } from 'react-router-dom'

OBS:
  - The action is "REPLACE"

When is useful?

  1 - We need to create a restrict area in the application (user logged);

  <li><Link to='/voltar-para-home'>Voltar para home</Link></li>
  
  <Route path='/voltar-para-home' render={() => <Redirect to='/' />} />

  Force in history:
  
    push={true} (or just push)

    It uses action PUSH, not REPLACE. That means it will include in history.

    <Redirect true to='/' />

    Obs: But not so often you may want to use push here.


When is useful?

  2 - Using inside directly in <Switch>. Good when we change URLs in our application.

      <Switch>
        <Route path='/' exact component={Home} />
        <Redirect from='/voltar-para-home' to='/' />
        <Route path='/(about|contact)/(1|2)?' component={Page} />
        <Route path='/blog' component={Blog} />
        <Route component={Error404} />
      </Switch>


class #029 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Component <Prompt />
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/03-hello-react-router/17

It blocks user's navigation, the PopUp window with a prompt (like in javascript).

<Route path='/cadastro' component={Register} />

const Register = () => (
  <Prompt when={true} message='Navegação bloqueada!' />
)

More used while user are filling a form and try to navigate out of the form without finish the form, asking if user really want to cancel the process.

if when={false}, user can keep his/her action without get blocked.

class #030 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Higher Order Component (HOC): withRouter()
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/03-hello-react-router/18

import { withRouter } from 'react-router-dom'

Does more or less what Route does without a component, it passes the props history, location, and match.

Given this code:

    const ButtonBack = ({ history }) => (
      <button onClick={(e) => history.goBack()}>{'<-'} Voltar</button>
    )

    const ButtonForward = ({ history }) => (
      <button onClick={(e) => history.goForward()}>Próxima página {'->'}</button>
    )

    <li><Route component={ButtonBack} /></li>
    <li><Route component={ButtonForward} /></li>

It could be that way:

    const ButtonBack_ = ({ history }) => (
      <button onClick={(e) => history.goBack()}>{'<-'} Voltar</button>
    )
    const ButtonBack = withRouter(ButtonBack_)

    const ButtonForward_ = ({ history }) => (
      <button onClick={(e) => history.goForward()}>Próxima página {'->'}</button>
    )
    const ButtonForward = withRouter(ButtonForward_)

    <li><ButtonBack /></li>
    <li><ButtonForward /></li>

Usually those comps will be in diferent files, being exported like:

    const ButtonForward = ({ history }) => (
      <button onClick={(e) => history.goForward()}>Próxima página {'->'}</button>
    )

    export default withRouter(ButtonForward)

and in case you want to also use the pure component:

    export const ButtonForward = ({ history }) => (
      <button onClick={(e) => history.goForward()}>Próxima página {'->'}</button>
    )

    export default withRouter(ButtonForward)

also another option if you get the not pure component, this way bellow you can use it witout the withRoute, like being actually pure:

    ButtonForward.WrappedComponent

Resume:
Use it when we have to pass react-router-dom props to a comp that actually is not using Router - not rendered by Route - and when you have to inject it, use withRouter.


class #031 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Provider: <HashRouter />
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/03-hello-react-router/19

It replaces the BrowserRouter. And includes a HASH in the URL.

import { HashRouter } from 'react-router-dom'

const App = () => (
  <HashRouter>
    <div>
      <ul>
        <li><ButtonBack /></li>
        <li><ButtonForward /></li>
      </ul>

      <ul>
      </ul>

      <Switch>
      </Switch>

    </div>
  </HashRouter>
)

Nowadays this is not so useful because most browsers now have support to history API, so now it's better to use BrowserRouter.

Back to the previous issue with Static Servers, where navigating throw the pages and the server does'nt redirect the routes to index.html:

When you try to reload the page, browser will try to find that specific static route in the server, and if it doesn't exist we get a 404 page. So we need a server that redirects all route calls to the index.html, then it loads our javascript, which loeads browser router, then we load all components we need.

At one time, you may have a client that have to use a specific server that, unfortunately, doesn't allow us to redirect everything to the index.html. That's when we use HashRouter. But it has some things to be aware:

Hashes used as scroll anchors - not extra pages - will also push data to history object. You may don't want this.

So use BrowserRouter. If server has this redirect issue, then use HashRouter. But mostly you won't need to use it. React Router has also other providers available.

http://localhost:3000/#/blog


class #032 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Solving problem - router not rendering
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/03-hello-react-router/20

URL changes, but component doesn't render.

in case we have:

src/app.js:
                const App = () => (
                  <BrowserRouter>
                    <MainApp />
                  </BrowserRouter>
                )

src/main-app.js:
                class MainApp extends PureComponent {
                  render () {
                    return (
                      <div>
                              ...blablabla
                      </div>
                    )
                  }
                }


It won't render the comps!

    { PureComponent } only renders again when props passed to it have any new changes or new states values. So this PureComponent won't render by default.

How to fix it?

    1. Use { Component }

                class MainApp extends Component {
                  render () {
                    return (
                      <div>
                              ...blablabla
                      </div>
                    )
                  }
                }

      We know Component renders again any time and that's the reason why we avoid it. We should use { Component } only when we have our own shouldComponentUpdate() implementation. Whitout it, we prefer to use PureComponent. So this might be a issue, it's a side effect/ colateral. So actually this #1 is not a solution.

      How to fix it keeping the { PureComponent } ?

      - Force any prop change

        Pick props that will change when a Route changes.

      2. Pass it inside Route

        { Route } always pass history, location, match; 

        Prop location always change when Route changes.

        So...

        src/app.js:
                const App = () => (
                  <BrowserRouter>
                    <Route component={MainApp} />
                  </BrowserRouter>
                )

        That way we are passing history, location and match to <MainApp/>


        3. Another way: { WithRouter }

        src/main-app.js:
                class MainApp extends PureComponent {
                  render () {
                    return (
                      <div>
                              ...blablabla
                      </div>
                    )
                  }
                }

                export default withRouter(MainApp)

        4. If inside a Route, pass prop location to the child pure component:

        src/app.js:

                const App = () => (
                  <BrowserRouter>
                    <Route render={({ history, location, match }) => (
                      <MainApp location={location} />
                    )} />
                  </BrowserRouter>
                )


        Conclusion:
        We may face those issues when we start to break our application in isolated components, so keep that in mind to remember how to fix it.


class #033 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
App: Pizza Store
CRUD: Create, Read, Update, Delete

Material Design
https://material-ui.com/

https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/04-reactzzaria/000-layout

class #034 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/04-reactzzaria/001/sistema-pedidos

CRA: Create React App

Terminal install CRA:

    yarn global add create-react-app

  or

    npm i -g create-react-app


Start a project:

  create-react-app <project name>



- Should we use our boilerplate or CRA?

CRA now is safe and already comes with many good features, it's specially good for build production versions.

Are we quitting the boilerplate forever? No!
Later, Daciuk will release a new module talking about webpack updates.

Just for the records, at the time professor recorder the class, his project was started with React 16.6.3. At the time I reached these same classes, my React version were 16.13.1.

one small change at package.json:

      "scripts": {
        "start": "react-scripts start"
      }

      replaced by:

      "scripts": {
        "dev": "react-scripts start"
      }

How to avoid React to auto open a browser's tab?

      Terminal:

        touch .env

        Include:
        
          BROWSER=null


class #035 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
File .env - Environment variables

Use it to set or edit env variables

File is read at the start of the project.

It's used by:

    "react-scripts": "3.4.1"

Use those variables for data specific of the environment.

Examples:

  NODE_ENV

Terminal:

  echo $NODE_ENV
  // development

In a production environment, we would set it to 'production'. Here, if we check, it says 'deveolpment'. Actually didn't happen with me, it returned nothing.

Front-end code doesn't have access to env variables.

class #036 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
React v16 - New Features

Fragment

Is the virtual DOM element that wraps everything inside a component

import { Fragment } from 'react'

      <Fragment>

      </Fragment>

In the rendered page, the DOM actually doesn't create this extra 'div'.

Iterating a list:

      <Fragment>
        {[1, 2, 3].map((item) => {
          <div key={item}>
            <span>Name: {item.name}</span>
            <span>Number: {item.number}</span>
          </div>
        })}
      </Fragment>

The same rule. We can replace this div with Fragment:

      <Fragment>
        {[1, 2, 3].map((item) => {
          <Fragment key={item}>
            <span>Name: {item.name}</span>
            <span>Number: {item.number}</span>
          </Fragment>
        })}
      </Fragment>

New sintax: <> </>

        <>
          {[1, 2, 3].map((item) => {
            < key={item}>
              <span>Name: {item.name}</span>
              <span>Number: {item.number}</span>
            </>
          })}
        </>

Without the CRA, using manually Babel, some adjustments must be done to have this new feature.

https://reactjs.org/blog/2017/11/28/react-v16.2.0-fragment-support.html


class #037 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

New Features: Lazy Method & Suspense Component
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/04-reactzzaria/001/sistema-pedidos

Used for dynamic import

1 - CRA also has it's own chunks.
2 - import()

-> Every time we use function import() with webpack, it separates this in different chunks. Dynamic loading.

So despite static import:

      import Img from './img'
      import P from './p'
      import A from './a'

... we do it dynamicaly:

      const Img = import('./img')
      const P = import('./p')
      const A = import('./a')

Then:

Error: Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: object. You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.

Why?

Because function import() returns a promisse, and react can't render a promisse.

That's when React.lazy comes:

    const Img = React.lazy(() => import('./img'))
    const P = React.lazy(() => import('./p'))
    const A = React.lazy(() => import('./a'))

So with 'Lazy' it will wait each promisse before move on.

Still with the error, but another message:

    Error: A React component suspended while rendering, but no fallback UI was specified.

    Add a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.

PS: Lazy works only with Suspense

src/app.js:

        import React, { Component, Suspense } from 'react';
        import './App.css';

        const Img = React.lazy(() => import('./img'))
        const P = React.lazy(() => import('./p'))
        const A = React.lazy(() => import('./a'))

        class App extends Component {
          render() {
            return (
              <Suspense fallback={<h1>Loading...</h1>}>
                <div className="App">
                  <header className="App-header">
                    <Img />
                    <P />
                    <A />
                  </header>
                </div>
              </Suspense>
            )
          }
        }

        export default App;

And now, with everything working, check the chunks loaded on the Network dev tools: every single import() has it's own chunk! We got the control of it!

Now supposed one of them takes longer to load, such as an image.

It show us all things only when all of them are already loaded. Can we change that and make it to show each part already loaded?

We just have to use Suspense once more to wrap again the one who takes longer

    return (
      <Suspense fallback={<h1>Loading...</h1>}>
        <div className="App">
          <header className="App-header">
            <Suspense fallback={<h1>Loading Image...</h1>}>
              <Img />
            </Suspense>
            <P />
            <A />
          </header>
        </div>
      </Suspense>
    )

We actually don't have to wrap the entire component with <Suspense>. We must wrap just the ones which the import is dynamic. In this case, just these ones:

        const P = React.lazy(() => import('./p'))
        const A = React.lazy(() => import('./a'))
        const Img = React.lazy(() => {
          return new Promise((resolve, reject) => {
            setTimeout(() => {
              resolve(import('./img'))
            }, 10000) // emulating long load
          })
        })

This way:

    return (
      <div className="App">
        <header className="App-header">
          <Suspense fallback={<h1>Loading...</h1>}>
            <Suspense fallback={<h1>Loading Image...</h1>}>
              <Img />
            </Suspense>
            <P />
            <A />
          </Suspense>
        </header>
      </div>
    )

By doing this, all the other things, including the style, will get laoded much earlier.

React's team still working on <Suspense> (by the time of this class).


class #038 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
Error Boundaries
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m04/04-reactzzaria/002/sistema-pedidos

Errors may break the entire application, we should know how to prevent this. We should have a kind of 'try / catch' to avoid the complete break of the application. To achieve that, we gonna use a static method:

getDerivedStateFromError:

  static getDerivedStateFromError () {
    return { hasError: true }
  }

  this is a built-in method that react triggers by default if any error occurr.

  https://reactjs.org/docs/error-boundaries.html

<ErrorBoundaries> protect the part of the application that didn't break. 

This component have to be above everything, wrapping everything.

src/error.js:

      import { PureComponent } from 'react'

      class ErrorBoundary extends PureComponent {
        state = { hasError: false }

        static getDerivedStateFromError () {
          return { hasError: true }
        }

        render () {
          return this.props.children(this.state.hasError)
        }
      }

      export default ErrorBoundary


src/index.js:

      import ErrorBoundary from './error'

      ReactDOM.render(
        <ErrorBoundary>
          {(hasError) => (
            <App hasError={hasError} />
          )}
        </ErrorBoundary>,
        document.getElementById('root')
      );

src/app.js:

      import React, { Component } from 'react';
      import logo from './logo.svg';
      import './App.css';

      class App extends Component {
        state = {
          products: []
        }

        handleClick = (e) => {
          e.preventDefault()

          const result = {}
          this.setState({
            products: result
          })
        }

        render() {
          const { hasError } = this.props

          return (
            <div className="App">
              <header className="App-header">
                {hasError && <h1>Deu problema :(</h1>}
                <img src={logo} className="App-logo" alt="logo" />
                <p>
                  Edit <code>src/App.js</code> and save to reload.
                </p>
                <a
                  className="App-link"
                  href="https://reactjs.org"
                  target="_blank"
                  rel="noopener noreferrer"
                  onClick={this.handleClick}
                >
                  Buscar produtos
                </a>

                {this.state.products.map((product) => (
                  <div key={product}>{product}</div>
                ))}
              </header>
            </div>
          );
        }
      }

      export default App;



      By passing the state to the children:

            return this.props.children(this.state.hasError)

      We are allowing the rest of the app to show different contents in case hasError is true or false.



class #039 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *






















class #040 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *























class #041 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *






















class #042 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *






















class #043 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *






















class #044 * *





















 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #045 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *






















class #046 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *






















class #047 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *






















class #048 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *






















class #049 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *






















class #050 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

class #051 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #052 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #053 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #054 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #055 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #056 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #057 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #058 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #059 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #060 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

class #061 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #062 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #063 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #064 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #065 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #066 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #067 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #068 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #069 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #070 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

class #071 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #072 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #073 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #074 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #075 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #076 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #077 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #078 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #079 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #080 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

class #081 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #082 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #083 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #084 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #085 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #086 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #087 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #088 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #089 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #090 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

class #091 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #092 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #093 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #094 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #095 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #096 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #097 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #098 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #099 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #100 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

class #101 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #102 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #103 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #104 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #105 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #106 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #107 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #108 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #109 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #110 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

class #111 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #112 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #113 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #114 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #115 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #116 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #117 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #118 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #119 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #120 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

class #121 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #122 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #123 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #124 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #125 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #126 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #127 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #128 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #129 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #120 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

class #131 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #132 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #133 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #134 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #135 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #136 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #137 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #138 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #139 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #130 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

class #141 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #142 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #143 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #144 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #145 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #146 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #147 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #148 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #149 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #150 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

class #151 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #152 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #153 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #154 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #155 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #156 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #157 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #158 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #159 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #160 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

class #161 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #162 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #163 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #164 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #165 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #166 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #167 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #168 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #169 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #170 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

class #171 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #172 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #173 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #174 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #175 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #176 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #177 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #178 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #179 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #180 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

class #181 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #182 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #183 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #184 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #185 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #186 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #187 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #188 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #189 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #190 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

class #191 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #192 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #193 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #194 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #195 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #196 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #197 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #198 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #199 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #200 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

class #201 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #202 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #203 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #204 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #205 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #206 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #207 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #208 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
class #209 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

