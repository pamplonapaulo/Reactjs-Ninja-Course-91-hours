"React.js Ninja" by Fernando Daciuk

Class Notes

    Class Support: https://github.com/da2k/curso-reactjs-ninja

        Functional Programming

        EcmaScript6 (2015 + 2016)

        Setting up environment (development and production)

    
    What is React?

    Not a framework, but a library to build User Interfaces

    It's the "V" of Model View Controller

    DOM manipulation:
    
        Webapps
        Mobile Apps
        CMSs

    Don't use React:

        Institutional Websites 
        Blogs

        (Doesn't make sense. It does make sense for more interactive areas)

    What problems React solve?

        Modularização (separação de responabilidades)

        Componentização (for User Interface)

        Performance (DOM manipulation, virtual DOM)


    http://facebook.github.io/react (https://reactjs.org/)

    
    
    https://cdnjs.com/libraries/react/15.1.0


    Starting a server:
    
        npm i http-server (installing the package)

        http-server (running the server)

        In my case I used:
        
            npx http-server ./
        
        (Using npx you can run the script without installing it first)



https://www.udemy.com/course/curso-reactjs-ninja/learn/lecture/7176634#overview
    

Module 1 | Class 4:

    Multiple Elements inside a parent Element.

        var h1 = React.createElement('h1', null, [
            React.createElement('span', null, 'Texto do Span'),
            React.createElement('i', null, 'Texto do Span 2')
        ]);

Module 1 | Class 5:

    JSX:

        Javascript + XML, created by Facebook Co.

        React.DOM object (doesn't have 100% of the tags)

            var h1 = React.DOM.h1(null, [
                React.DOM.span(null, React.DOM.i(null, 'Italic')),
                React.DOM.span(null, 'Texto do Span 2')
            ]);

        JSX is a more visual way to write a code like 'React.createElement'

        'JSX is optional and not required to use React. Try the Babel REPL to see the raw JavaScript code produced by the JSX compilation step.'


        Babel (JS compiler)

        - Add the CDN:
        <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.34/browser.min.js"></script>

        - Helps the Browser to render ECMA6+

            <script type="text/babel">

                ReactDOM.render(
                    <h1>Hello World</h1>,
                    document.getElementById('app')
                );

            </script>

        - Newest versions don't work that way!


Module 1 | Class 6: Create Class + Render Method

    React Components should starts with an uppercase letter:

        var Title = React.createClass({
            render: function() {
                return (
                    <div>
                        <h1>
                            <i>First H1</i>
                        </h1>
                        <h1>
                            <i>Second H1 wrapped by the same DIV</i>
                        </h1>
                    </div>
                ) 
            }
        })

        ReactDOM.render(
            <Title />,
            document.getElementById('app')
        );
    

    PS: We can't brak a line just after 'return'. Use parentheses to wrap the 'HTML'.

    => We can't have two HTML tags beside each one. Classes are always wrapped by a single parent inside the parentheses. This is cuz a function with 'return' will return just once, so you must wrap eveything inside one single element. Just throw a DIV wrapping everything when you need it.


Section 2 | Class #1: Environment Settings + Webpack

Daciuk's settings:

    https://github.com/da2k/curso-reactjs-ninja/tree/master/config


Webpack

    It's a module bundler: http://webpack.github.io/


Section 2 | Class #1.1: Versions and dependencies

        From this point we may be using old versions. Make sure we are following these versions:

        https://github.com/da2k/curso-reactjs-ninja/blob/master/versions-of-dependencies.md


Section 2 | Class #2: Starting up with Webpacks

    npm install --save-dev webpack@1
    or npm install --save-dev webpack (to get the last stable version)

    Basic config of Webpack.config.js

        touch webpack.config.js

    Now edit it. Include:

        'use strict'

        const path = require('path')

        module.exports = {
            entry: path.join(__dirname, 'src', 'index'),
            output: {
                path:path.join(__dirname, 'dist'),
                filename: 'bundle.js'
            }
        }

    'src' directoy:

        mkdir src
        cd src
        touch index.js

    webpack:

        cd ..
        npm install -g webpack@1

        webpack

    index.html:

        touch index.html


Section 2 | Class #3: Web Server

    section-2 (dev) npm install --save-dev webpack-dev-server@1
    or
    section-2 (dev) npm install --save-dev webpack-dev-server (to get the last stable version)


    Now add the public path at web.config

        publicPath: '/static/'
        (this is using a virtual memory to store a file - the folder itself actually doesn't exist)

    Fix the path at the index.html:

        <script src="/static/bundle.js"></script>

    
    Install the webpack server globally:
    
        npm install -g webpack-dev-server@1

    Run it.

        webpack-dev-server

Section 2 | Class #4: Moduling an App


    require + exports

        index.js
        var sum = require('./app')

        app.js
        module.exports = sum


Section 2 | Class #5: React + ReactDOM from Nodle Package Management (NPM)


        (dev) npm install --save react@15.4 react-dom@15.4
        or
        (dev) npm install --save react react-dom


PS: Something that I had forgoten:

    Every time you select something from ID inside your JS, it goes to the global memmory. So it's a bad practice.



Section 2 | Class #6: EcmaScript 2015



    Babel dependencies

        npm install --save-dev babel-core@6 babel-loader@6 babel-preset-es2015@6 babel-preset-stage-0@6

        or

        npm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-stage-0

    Babel config:

        .babelrc (hidden file)

        edit it. Add this:

            {
                "presets": ["es2015", "stage-0"]
            }

        
        import + export

            index.js
            import Title from './app'

            app.js
            export default Title


    Shorthand notation:

        import { render } from 'react-dom'

        render(
            React.createElement(Title),
            document.querySelector('[data-js="app"]')
        )

    Longhand Notation:

        import { render : render } from 'react-dom' (with unknown error compiling)

        ReactDOM.render(
            React.createElement(Title),
            document.querySelector('[data-js="app"]')
        )

Section 2 | Class #6.0.1: ES Modules (Daciuk's notes from the 'future')

    Fixing mistakes from last video: forget about shorthand/longhand notation.

    Named Import / Named Export

    export WITHOUT default // named export:

        ./react-dom.js

            export function render() {
                console.log('hello render')
            }
            export { render } ***** this is a named export *****

        ./index.js

            import { render } from './react-dom'
            render(
                React.createElement(Title),
                document.querySelector('[data-js="app"]')
            )

        It could be this other way:

            ./react-dom.js

                function render() {
                    console.log('hello render')
                }
                export { render }

            ./index.js

                // Here you have to use this name.
                import { render } from './react-dom'

                // But you could make this:
                import { render as reactDomRender } from './react-dom'
                reactDomRender(
                    React.createElement(Title),
                    document.querySelector('[data-js="app"]')
                )

            Long story short:

                import ... 'as' ...

                To rename a object exported by a named export, use keyword "as"
                    import { render as reactDomRender } from './react-dom'


            Long X Short:

            This:

                function render() {
                    console.log('hello render')
                }
                var ReactDOM = {}
                ReactDOM.render = render
                export default ReactDOM

            Is the same as:

                function render() {
                    console.log('hello render')
                }
                export default {
                    render: render
                }

            But since the property has the same name as the method...

                function render() {
                    console.log('hello render')
                }
                export default { render }

            But in case you have to name a value, so take of the 'default'...

                function render() {
                    console.log('hello render')
                }
                export { render }

            Or:

                export function render() {
                    console.log('hello render')
                }

            Or:

                export default function () {
                    console.log('hello render')
                }


    OBS:
    'use strict' is not a need on modules. Daciuks keep doing by his habit.


Section 2 | Class #7: Setting JSX at Babel and sourcemaps at webpack

    PRESET (makes Babel recogniza JSX)

    npm install --save-dev babel-preset-react@6 (version in this course)

    or

    npm install --save-dev babel-preset-react (newer)

    Update something at .babelrc. Include "react" at the end of the preset's array:

        {
            "presets": ["es2015", "stage-0", "react"]
        }

    Update app.js:
    
        var Title = React.createClass({
            render: function(){
                return <h1>babel-preset-react is working</h1>
            }
        })

    Update index.js:

        render(
            <Title />,
            document.querySelector('[data-js="app"]')
        )


    However, how could we debug this code in case we need it? It's not easy to understand file './dist/bundle.js'. This is why we use sourcemap.

        Add an extra entry at:
        
            webpack.config

                module.exports = {
                    devtool: 'sourcemap',
                    (...)
                }

            Boom! Now if we have to debug anything, console will show us the original files where we are working on, not the bundle.js. Super cool.


Section 2 | Class #8: React Hot Loader

    HTML/CSS: Live Reload Mode

    React Hot Loader: For each update in every component, only it's tree will be reloaded.

    Installing it.

        npm install --save-dev react-hot-loader@3.0.0-beta.2 (version in this course)

    The idea is to heve this onli in the development, not under production. Later we will set this too.

    Update webpack.config:

        Include this:

            entry: [
                'react-hot-loader/patch',
                'webpack-dev-server/client?http://localhost:3000',
                'webpack/hot/only-dev-server'
            ],

            plugins: [
                new webpack.HotModuleReplacementPlugin()
            ],

    Update .babelrc:

        Include this line:

            {
                "plugins": ["react-hot-loader/babel"]
            }
            
    Touch server.js (to be run with Node.js)

    Start entry at package.json


Section 2 | Class #9: React Hot Loader (Part II)

    So far so good? Not really. Now we'll include a feature that auto-reloads contents when something change in the page.

    We need to include this in index.js:

        import { AppContainer } from 'react-hot-loader'

    At index.js:

        import React from 'react'
        import { render } from 'react-dom'
        import { AppContainer } from 'react-hot-loader'
        import App from './app'

        render(
            <AppContainer>
                <App />
            </AppContainer>,    
            document.querySelector('[data-js="app"]')
        )

        if(module.hot) {
            module.hot.accept('./app', () => {
                const NextApp = require('./app').default

                render(
                    <AppContainer>
                        <App />
                    </AppContainer>,    
                    document.querySelector('[data-js="app"]')
                )

            })
        }
    
        How is our structure:

            index.js calls app.js, and app.js calls everything it needs

        OBS on app.js:

            This:

                export default App

            Is the same as:

                exports.default = App

Section 2 | Class #10: Linter

    New dependencies:

        - standard
        - standard loader

    Terminal:

        npm install --save-dev standard standard-loader@4

    Linter have to be loaded before Babel.

        So, on webpack.config:

            module: {

                preLoaders: [{
                    test: /\.js$/,
                    exclude: /node_modules/,
                    include: /src/,
                    loader: 'standard'
                }],

                loaders: [{
                    test: /\.js$/,
                    exclude: /node_modules/,
                    include: /src/,
                    loader: 'babel'
                }]
            }

    Linter standard gives you warnings if your code has semicolon or if it's indentation has more or less spaces than it's standard.

    Webpack validator: helps you to find errors at webpack.config.js

        npm install --save-dev webpack-validator

    

Section 3: Módulo 1 parte 2 * * * * * * *



Section 3 | #07: Props

    Props are like html attriutes

            from: title.js
                <Title name='Fernando Daciuk'/>

            to: app.js
                <h1>Hello {this.props.name}!</h1>

            returns:
                Hello Fernando Daciuk!


Section 3 | #08: className + htmlFor

    CLASS is a keyword in JS. So use className.

            <div className='do-not-use-class' id='id-is-ok'>


    FOR also is a keyword in JS. So use htmlFor.

            <label htmlFor=''>Input</label>
            <input id='input' type='text'/>


Section 3 | #09: getDefaultProps

            from: title.js
                const Title = React.createClass({
                    getDefaultProps: function () {
                        return {
                            name: 'Desconhecido',
                            lastName: 'Sorenome'
                        }
                    },
                    render: function () {
                        return (
                        <h1>Hello {this.props.name + ' ' + this.props.lastName}!</h1>
                        )
                    }
                })

            to: app.js
                const App = React.createClass({
                    render: function () {
                    return (
                        <div className='do-not-use-class' id='id-is-ok'>
                        <Title name='Fernando'/>
                    </div>
                    )
                }
                })

            returns:
                Fernando Sorenome!

        

    
Section 3 | #10: getDefaultProps beyond strings

            Number

                from: title.js
                    <h1>Hello {this.props.name + ' ' + this.props.age}!</h1>

                to: app.js
                    <Title name='Fernando' age={40}/>

            Arrays

                from: title.js
                    <h1>Hello {this.props.name + ' ' + this.props.scores}!</h1>

                to: app.js
                    <Title name='Fernando' scores={[40,100, 0, 20]}/>


            object

                from: title.js
                    <h1>Hello {this.props.name + ' has a car made by ' + this.props.car.model + ' on ' + this.props.car.year}!</h1>

                to: app.js
                    <Title name='Fernando' car={{model: 'Wolks', year: 1980}} />

Section 3 | #11: Render with pure functions insted of React.createClass():

    option 1

        const Title = () => {
            return (
                <h1>Oi</h1>
            )
        }

    option 2

        const Title = () => <h1>Oi</h1>

    option 3

        const Title = (props) => (
            <h1>Oi, {`${props.name} ${props.car.model}`}</h1>
        )

    option 4

        const Title = ({ name, car }) => (
            <h1>Oi, {`${name} ${car.model}`}</h1>
        )

    option 5

        const Title = ({ name, car }) => (
            <h1>Oi, {`${name} ${car.model}`}</h1>
        )

        Title.defaultProps = {
            name: 'Unknown',
            car: {
                model: 'Tesla'
            }
        }

    

Section 3 | #12: Render with classes (ES6)

import React, { Component } from 'react'

class App extends Component {
  render () {
    return (
      <div className='container'>
        <Title name='Fernandos' />
      </div>
    )
  }
}

Section 3 | #13: prop key (use it on every loop)

const Square = ({ color }) => (
    <div style={{
        backgroundColor: color,
        height: '100px',
        width: '100px'
    }} />
)

Square.defaultProps = {
    color: 'red'
}

ALSO:

class App extends Component {
  render () {
    return (
      <div className='container'>
        {['yellow', 'blue', 'blue', 'black'].map((square, index) => (
          <Square key={index} color={square} />
        ))}
      </div>
    )
  }
}

OBS.mistakes:

      {repos.map((repo, index) => (
        <li><a key={index} href={repo.link}>{repo.name}</a></li>
      ))}

What is wrong? How to fix?

      {repos.map((repo, index) => (
        <li key={index}><a href={repo.link}>{repo.name}</a></li>
      ))}

Section 3 | #14: 

Never have a duplicated key={} !
Duplicated keys wont be render!

Section 3 | #15: Events (async)

    Mostly:

    - inline (actually react will create a listener, ot a inline html event)
    - arrow functions
    - 'onEventname'

      <div className='container' onClick={function (e) {
        alert('click')
      }}>



Section 3 | #16: Prop children

    button.js:
        import React from 'react'
        const Button = ({ children }) => (
            <button>{children}</button>
        )
        export default Button

    app.js:
        return (
        <div className='container'>
            <Button>
                <span>span *</span>
                outside
            </Button>
        </div>
        )

    
Section 3 | #17: Composition

a function:
    const sum = (x, y) => x + y

a composition:
    sum(sum(sum(3, 4), 2), sum(1, 1))

on react (using JSX):

    button.js
        import React from 'react'
        const Button = ({ children, handleClick }) => (
            <button className='main-button' onClick={handleClick}>          {children}
            </button>
        )
        export default Button

    search-button.js
        import React from 'react'
        import Button from './button'
        const SearchButton = () => (
            <Button handleClick={() => alert('search')}>
                Search
            </Button>
        )
        export default LikeButton

    like-button.js
        import React from 'react'
        import Button from './button'
        const LikeButton = () => (
            <Button handleClick={() => alert('like')}>
                Like
            </Button>
        )
        export default LikeButton

    app.js
        class App extends Component {
            render () {
                return (
                <div className='container'>
                    <LikeButton />
                    <SearchButton />
                </div>
                )
            }
        }

Section 3 | #18: State

Props can't change. So we use State to get any change.

{this.state}

state does not work in pure function components
        
super() method

    gets methods from constructor

this.setState

    once the state changes, the render reload stuff

class App extends Component {
  constructor () {
    super()
    this.state = {
      text: 'Paulo'
    }
  }
  
  render () {
    return (
      <div className='container' onClick={() => this.setState({
        text: 'Outro texto'
      })}>
        {this.state.text}
      </div>
    )
  }
}

Section 3 | #19: Arrow functions

- always anonymous

- if has one line, doesn't need 'return' keyword and doesn't need curly brackets.

var sum = (x, y) => x + y

- of just one parameter, no parentheses needed

var add1 = x => sum(x,1)

- the real advantage actually it hasn't lexical scope: old sintax wouldn't get 'this.setState', cuz 'this' would be the 'function' itself, not the class.

onClick={() => this.setState({ text: 'Outro texto' })}>

- it does not contain the arguments object

- it can't create a costructor - you must use a normal function


Section 3 | #20: stateful X stateless

    stateful: able to manipulate states.

    stateless: pure functions can't manipulate states (see our buttons)

    React tem fluxo de dados unidirecional. (De pai para filho/ Cima para baixo)

    Todo método render() precisa ser uma função pura, não pode gerar side effects.

Section 3 | #21: lifecycle

    - mounting / unmounting
    - updating

    Each one has specific methods

    mounting / unmounting:

        1. componentWillMount()
        2. componentDidMount()
        3. componentWillUnmount()

    updating:

        1. componentWillReceiveProps(nextProps)
        2. shouldComponentUpdate(nextProps, nextState) => bool
        3. componentWillUpdate(nextProps, nextState)
        4. componentDidUpdate(prevProps, prevState)


Section 3 | #22: mounting / unmounting

OBS: React runs either on the server side or in the client side. So do not manipulate DOM with componentWillMount or anything that could mess something on the server side.

componentWillMount() = component is not in the DOM yet when this method runs.
mounting = it means build a component in the dom. (component ready)

constructor() runs just when the Class is instantiated, then componentWillMount() runs, then render() runs after all. Then componentDidMount() would run.

componentDidMount() it's the proper method if you have to manipulate the DOM.

componentWillUnmount()

time.js:

class Timer extends Component {
    constructor () {
        super()
        this.state = {
            time: 0
        }
        
        this.timer
    }

    componentDidMount () {
        this.timer = setInterval(() => {
            this.setState({ 
                time: this.state.time + 1 
            })
        }, 1000)
    }

    componentWillUnmount () {
        clearInterval(this.timer)
    }

    render () {
        return <div>Timer: {this.state.time}</div>
    }
}

app.js:

class App extends Component {
  constructor () {
    console.log('constructor');
    super()
    this.state = {
      showTimer: true
    }
  }

  render () {
    return (
      <div>
        {this.state.showTimer && <Timer />}

        <button onClick={() => {
          this.setState({ showTimer: !this.state.showTimer })
        }}>show / hide time</button>
      </div>
    )
  }
}

Section 3 | #23: updating: componentWillReceiveProps(nextProps)

- use it only after get the DOM set.

- 

Section 3 | #24: updating:  shouldComponentUpdate(nextProps, nextState) => bool

- this function runs every time something in the DOM updates

- good for value tests: is this.props.time !== nextProps.time?

- if somehow you don't want the component to render

- do not use promises or ajax, just a fast condition that returns true or false



Section 3 | #25: updating:  componentWillUpdate(nextProps, nextState)

- last moment before component update

- do not use this.setState inside it (issues may occur)
OBS: this.setState can be used only inside componentWillReceiveProps()

So, after all, how do all these steps in lifecycle behave (from the view of console.log)?

    constructor app
    componentWillMount app
    render app
        constructor timer
        componentWillMount timer
        render timer
        componentDidMount timer
    componentDidMount app

Also, the updates (when it happen):

    componentWillReceiveProps timer
    componentWillUpdate timer
    componentDidUpdate timer

app.js

'use strict'

import React, { Component } from 'react'
import Timer from './timer.js'

class App extends Component {
  constructor () {
    console.log('constructor app')
    super()
    this.state = {
      time: 0,
      showTimer: true
    }
  }

  componentWillMount () {
    console.log('componentWillMount app')
  }

  componentDidMount () {
    console.log('componentDidMount app')
  }

  componentWillUnmount () {
    console.log('componentWillUnmount app')
  }

  render () {
    console.log('render app')
    return (
      <div>
        <Timer time={this.state.time} />

        <button onClick={() => { this.setState({ time: this.state.time + 10 }) }}>Change props</button>
      </div>
    )
  }
}

export default App

timer.js

'use strict'

import React, { Component } from 'react'

class Timer extends Component {
  constructor () {
    console.log('constructor timer')
    super()
    this.state = {
      time: 0
    }

    this.timer
  }

  componentWillReceiveProps (nextProps) {
    console.log('componentWillReceiveProps timer', this.props, nextProps)
  }

  shouldComponentUpdate (nextProps, nextState) {
    //console.log('shouldComponentUpdate timer', this.state, nextState)
    return this.props.time !== nextProps.time
  }

  componentWillMount () {
    console.log('componentWillMount timer')
  }

  componentWillUpdate (nextProps, nextState) {
    console.log('componentWillUpdate timer', this.props, nextProps)
  }

  componentDidMount () {
    console.log('componentDidMount timer')
    this.timer = setInterval(() => {
      this.setState({
        time: this.state.time + 1
      })
    }, 1000)
  }

  componentWillUnmount () {
    console.log('componentWillUnmount timer')
    clearInterval(this.timer)
  }

  render () {
    console.log('render timer')
    return <div>Timer: {this.state.time}</div>
  }
}

export default Timer


Section 3 | #26: componentDidUpdate(prevProps, prevState)


Section 3 | #27: propTypes

ex:
Button.propTypes = {
  handleClick: React.PropTypes.func.isRequired
}

app.js
class App extends Component {

  render () {
    return (
      <div>
        <Button handleClick={() => console.log('cliked')}>Click me</Button>
      </div>
    )
  }
}

button.js
const Button = ({ children, handleClick }) => (
  <button className='main-button' onClick={handleClick}>
    {children}
  </button>
)

Button.propTypes = {
  handleClick: React.PropTypes.func.isRequired
}

MORE:
https://reactjs.org/docs/typechecking-with-proptypes.html#proptypes

Section 3 | #28: Forms

    <input /> is not an HTML element, it's actually a function from React. Therefore, it doesn't have same behavior. In case you set 'value="any value"', this can't be changed by the user. You could insted use "defaultValue='Default Value'", or the way bellow here:

    1. Controlled Components (best practice):

        (those are stateless, these components don't keep an own state:)

        class App extends Component {
            constructor () {
                super()
                this.state = {
                value: 'Valor inicial'
                }
            }
            render () {
                return (
                <div>
                <form>
                    <input type='text' value={this.state.value} onChange={(e) => {
                    console.log(e.target)
                    console.log(e.nativeEvent)
                    this.setState({
                        value: e.target.value
                    })
                    }} />
                </form>
                </div>
                )
            }
            }

    2. Uncontrolled component:

        (stateful component: without the 'value' attribute)

        <input type="text" defaultValue='Default Value' />

    Stateless X Stateful:

        Easier for React to manage differences between JSX (virtual DOM) and the real DOM when components are stateless. Use stateless!



        
Section 3 | #29: Checkboxes & Radio

    Controlled:

        <label>
            <input 
            type='checkbox' 
            value='my-checkbox1' 
            checked={this.state.checked} 
            onChange={(e) => {
            this.setState({ checked: !this.state.checked })
            }} />
            Controlled
        </label>

    Uncontrolled:

        <label>
            <input
            type='checkbox'
            value='my-checkbox2'
            defaultChecked1 />
            Uncontrolled
        </label>

    Also there is another option for events on this: onClick()

        <input type='checkbox' onClick={} />

    ps: onClick or onChange would work the same way for checkbox or radio.


Section 3 | #30: Select & Option

      <form>
        <select>
          <option value='1' selected>Option 1</option>
          <option value='2'>Option 2</option>
          <option value='3'>Option 3</option>
        </select>
      </form>

    or:

    <form>
        <select value='3'>
            <option value='1'>Option 1</option>
            <option value='2'>Option 2</option>
            <option value='3'>Option 3</option>
        </select>
    </form>

    but just like before, that won't allow user to change it.

    so...

    <form>
        <select value={this.state.value} onChange={(e) => {
        this.setState({
            value: e.target.value
        })
        }}>
            <option value='1'>Option 1</option>
            <option value='2'>Option 2</option>
            <option value='3'>Option 3</option>
        </select>
    </form>

    and multiple:

      <form>
        <select multiple value={['1', '3']} onChange={(e) => {
          this.setState({
            value: e.target.value
          })
        }}>
          <option value='1'>Option 1</option>
          <option value='2'>Option 2</option>
          <option value='3'>Option 3</option>
        </select>
      </form>


Section 3 | #31: Textarea

    <form>
        <textarea defaultValue={'Content with\n break line'} />
    </form>


Section 3 | #32: Form Events


    - onChange
    - onInput (not recomended)
    - onSubmit

      <form onSubmit={(e) => {
        e.preventDefault()
          console.log('event', e)
        }}
        
        onChange={(e) => {
          console.log('name', e.target.name)
          console.log('value', e.target.value)
        }}
        >
        <input type='name' name='name' />
        <input type='email' name='email' />
        {/* <input type='checkbox' onClick={} /> */}
        <button type='submit'>Submit</button>
      </form>


Section 3 | #33: setState is async

There is a option of a call back function when setState runs. So in this case the 'content' is shown after the execution of tje setState. 

class App extends Component {
  constructor () {
    super()
    this.state = {
      checked: false,
      showContent: false
    }
  }

  render () {
    return (
      <div>
        <label>
          <input
            type='checkbox'
            checked={this.state.checked}
            onChange={() => {
              this.setState({
                checked: !this.state.checked
              }, () => {
                this.setState({
                  showContent: this.state.checked
                })
              })
            }}
          />Show content
        </label>

        {this.state.showContent && <div>Look at me!</div>}
      </div>
    )
  }
}

Section 3 | #34: GitHub App (intro)

- ajax

- DOM libs

- stateful X stateless

- smart X dumb

- container X presentational

GitHub App:
https://github.com/da2k/curso-reactjs-ninja/tree/master/examples/m01/github-app

GitHub API:
https://api.github.com/users

https://developer.github.com/v3/
https://developer.github.com/v4/


Section 3 | #35: App's Markup

Section 3 | #36: App's Components + propTypes

Section 3 | #37: App's States + Concepts

    Stateful x Stateless
    
        App: this component will be stateful (sends data via props to it's children components, which will all be stateless)

    Container X Presentational

        Presentational just presents/shows content. It just render properties received from it's parent.

    Smart X Dumb

        Dumb: doesn't know what to do, just that they supposed to render properties.


Section 3 | #38: App's States (cont.)

obs: shortcircuit-ternary always shows a value, unless the value is null.

{!!userinfo && <UserInfo />}


Section 3 | #39: App's States (cont.)

Section 3 | #40: App's Request / Ajax Lib

    npm i --save @fdaciuk/ajax

Section 3 | #41: App's Populating

I might need this later again:
https://stackoverflow.com/questions/29280445/reactjs-setstate-with-a-dynamic-key-name


Section 3 | #42: App's Populating (Solving the challenge: Repos + Starred)

Section 3 | #43: App's Populating (Solving the challenge: Cont.)

Section 3 | #44: App's Populating (Solving the challenge: Cont.)

Não pense em manipular DOM. Pense manipulação de dados.

Section 3 | #45: Events (isDisable - rever esse vídeo!!!)

Section 3 | #46: Loading (isFetching - rever esse vídeo!!!)

Section 3 | #47: Organizando propTypes

Section 3 | #48: Bind (this - rever esse vídeo!!!)

    arrow function has a lexical bind:

        handleSearch={(e) => this.handleSearch(e)}

    this's reference is not lost. it keeps from the Class.

    or:

        handleSearch={this.handleSearch.bind(this)}

    Here again, this has a reference from the Class. Bind however is slower, so use arrow function.

    or even better, at the constructor (and just one time!):

        constructor () {
          super()
          this.state = {
            userinfo: null,
            repos: [],
            starred: [],
            isFetching: false
          }

          this.handleSearch = this.handleSearch.bind(this)
        }

    Then at the render:

        render () {
            return <AppContent
            isFetching={this.state.isFetching}
            handleSearch={this.handleSearch}
            getRepos={this.getRepos('repos')}
            getStarred={this.getRepos('starred')}
            />
        }

    So above 'this' is already from the App's object. That's the most recommended way, cuz it's the most perfomatic. Put the 'bind' inside the constructor!

    Just good to know: Moving backwards - about ES5 -, building a component by 'const App = react.createClass()' it has already a built in 'bind', we don't need to include it again to get Class' reference. Kinda 'auto-bind'.

Section 3 | #49: Spread Operator (ES6)

    What is this? It's a reticent before an object. Like:

        ...obj

    What it does?
    
    Suppose we have this obj:

      const obj = {
          prop1: 1,
          prop2: 2,
          prop3: 3,
      }

      const obj2 = obj
      console.log(obj2 === obj) // true

    But... If we had done this way:

      const obj2 = { ...obj }
      console.log(obj2 === obj) // false

    It works on arrays, JSX, 

    So, in a real world code. This:

        render () {
            return <AppContent
            userinfo={this.state.userinfo}      <==
            repos={this.state.repos}            <==
            starred={this.state.starred}        <==
            isFetching={this.state.isFetching}  <==
            handleSearch={this.handleSearch}
            getRepos={this.getRepos('repos')}
            getStarred={this.getRepos('starred')}
            />
        }

    Could be written like this:

        render () {
            return <AppContent
            {...this.state}
            handleSearch={this.handleSearch}
            getRepos={this.getRepos('repos')}
            getStarred={this.getRepos('starred')}
            />
        }

    And that way we actually would be passing all the current state just at once. Super shortcut. (Since we had those 3 lines defined before at the code - see app.js)

    The spread operator spreads someone's properties somewhere else. Very modern sintax.

    Using Spread Operator with arrays:

        let arr = [1, 2, 3]
        function sum(a, b, c){
            return a + b + c
        }
        sum(1,2,3) //6
        sum.apply(null, arr) //6
        sum(...arr) //6

    







Section 3 | #50: 
