"React.js Ninja" by Fernando Daciuk

* Module 2 *

Class Notes


      class #50 - Pagination (starting)

        Test env.

        Install:
        jest-cli + babel-jest + chai

        Run:

          yarn add --dev jest-cli babel-jest chai
          ==> (yarn add --dev jest-cli@15 babel-jest@15 chai)

        Make some dirs:

        src/ utils

            / utils / pagination

        New files:

            / pagination / index.js
            / pagination / pagination.test.js



      class #51 - Setting up 'linter'

      Since jest test watch has it's own interface to run tests, linter needs another extra command. We already got standard and standar-loader. So at our package.json:

        "scripts": {
          "lint": "standard"
        }

      But if you have a try, you will see it's poor and not enough, we can improve the way it shows our errors.

      Some extra installs: snazzy  + gulp

        yarn add --dev snazzy

      One extra change at package.json:

        "scripts": {
          "lint": "standard --verbose | snazzy"
        }

      Boom. Now we have much more details about Linter's warnings. Run "yarn lint" to check this out.

      Also: Lint:Fix

        "scripts": {
          "lint": "standard --verbose | snazzy",
          "lint:fix": "standard --fix"
        }

      Running "yarn lint:fix" fixes the problem.

      However... By default 'standard' doesn't come with a 'watch' tool. So let's install something else: GULP

        yarn add --dev gulp
        For this class 'back in time': (npm i --save-dev gulp@3.9.1)

        Warning: we supposed to chose between YARN and NPM, not use both.

      At our root create a 'github-app/gulp.File.js'

      Edit it:

        'use strict'

        const gulp = require('gulp')
        const { spawn } = require('child_process')

        gulp.task('lint', (cb) => {
          const cmd = spawn('yarn', ['lint'], { stdio: 'inherit'})
          cmd.on('close', () => cb())
        })

        gulp.task('default', ['lint'], () => {
          gulp.watch('src/**/*.js', ['lint'])
        })

      Then run the watch at Terminal:

        yarn lint:watch

      
      class #52 - Paginação - implementação inicial

          So this class starts with Daciuk running:

          1. JEST

            yarn test:watch (which is the testing server)

              (and actually it runs:
                yarn test -- --watch
                plus
                jest --coverage --watch
              )

            Since our package.json includes those scripts:

                "scripts": {
                  "test": "jest --coverage",
                  "test:watch": "yarn test -- --watch",
                }, (and more not showed here)

          2. LINT

            At another Terminal window, Daciuk also runs:

              yarn lint:watch (which watches lint issues)


        If both are watching stuff nicely, move on...
        
        Now at:

          utils/pagination/pagination.test.js

            'use strict'

            import { expect } from 'chai'
            import pagination from './index'

            test('pagination should be a function', () => {
              expect(pagination).to.be.a('function')
            })

          // But 'test' is a global function, and 'standard' still doesn't know about global functions. So let's include something else at package.json to let 'standard' understand those global functions:

          package.json (at the bottom):

            "standard": {
              "globals": [ "test", "it", "describe" ]
            }
            


          utils/pagination/index.js


          {
              "presets": ["es2015", "stage-0", "react"],
              "plugins": ["react-hot-loader/babel"]
          }

          OK. I got a real issue and stared over my folder from professor's WorkFlow folder link.

          Then back to the code, typing the function pagiantion and it's test.

          Just a reminder about 'destructuring' (from ES6):

          Normally we use to code like that:

            const pagination = (params) => {
            }

          With destructuring, here is the new way:

            const pagination = ({ total, activePage }) => {
            }

        

          So far, our component still that simple:

            const pagination = ({ total, activePage }) => {
              let pages = []
              for (let i = 0; i < total; i++) {
                pages.push(i + 1)
              }

              return pages
            }

          But much cooler than that is that 'hack' (possible since ES5):

            const pagination = ({ total, activePage }) => {
              return Array.apply(null, { length: total }).map((_, i) => i + 1)
            }

            OBS: The underscore means we are not using map's first parameter, which would be the 'value' (or 'item' if you will). We are taking just the index, which is the second parameter.

          And there is the solution from ES6: from()

            from's second parameter is already the 'map' method. So:

            return Array.from({ length: total }, (_, i) => i + 1)


          Thinking about the needs:

          Logic rules:

            1. Pagination always shows the first page and the last page
            2. Pagination always shows the nearest pages
            3. Etc (...) cannot replace a single page, it have to be more two or more.

          So our schema looks like:

          Pages'amount    |   Active page   |   Rendered

          5                 1                 [1, 2, 3, 4, 5]
          5                 2                 [1, 2, 3, 4, 5]
          5                 3                 [1, 2, 3, 4, 5]
          5                 4                 [1, 2, 3, 4, 5]
          5                 5                 [1, 2, 3, 4, 5]

          6                 1                 [1, 2, 3, ..., 6]
          6                 2                 [1, 2, 3, ..., 6]
          6                 3                 [1, 2, 3, 4, 5, 6]
          6                 4                 [1, 2, 3, 4, 5, 6]
          6                 5                 [1, ..., 4, 5, 6]
          6                 6                 [1, ..., 4, 5, 6]

          7                 1                 [1, 2, 3, ..., 7]
          7                 2                 [1, 2, 3, ..., 7]
          7                 3                 [1, 2, 3, 4, ..., 7]
          7                 4                 [1, 2, 3, 4, 5, 6, 7]
          7                 5                 [1, ..., 4, 5, 6, 7]
          7                 6                 [1, ..., 5, 6, 7]
          7                 7                 [1, ..., 5, 6, 7]


          Tratamento de exceções (erros):

          1 - Dev esqueceu de passar param 'active':

          test('pagination({ total: 15 }) should return [1, 2, 3, "...", 15]', () => {
            const params = { total: 15 }
            const result = [1, 2, 3, '...', 15]
            expect(pagination(params)).to.be.deep.equal(result)
          })

          No caso, queremos que o código assuma que a página ativa é a 1.

            const pagination = ({ total, activePage = 1 }) => { }

          And just that we got it.

          2 - Dev esqueceu de passar param 'active' e 'total':

            E também queremos que o código assuma que o outro parâmetro esquecido também seja igual a 1, isto é, total = 1.

            const pagination = ({ total = 1, activePage = 1 }) => { }

          3 - Dev esqueceu de passar tudo:

          test('pagination() should return [1]', () => {
            const result = [1]
            expect(pagination()).to.be.deep.equal(result)
          })

          Vale a mesma regra: valores esquecidos serão '1':

            const pagination = ({ total = 1, activePage = 1 } = {}) => { }

          4 - Dev passa string ao invés de number:

          pagination.test.js:

            test('pagination({ total: 1, activePage: "abc" }) should throw an error', () => {
              const params = { total: 1, activePage: 'abc' }
              const result = 'activePage should be a number'
              try {
                pagination(params)
              } catch (e) {
                expect(e.message).to.be.equal(result)
              }
            })

          pagination.js:

            const isNumber = (value) => typeof value === 'number'

            const pagination = ({ total = 1, activePage = 1 } = {}) => {
              if (!isNumber(total)) {
                throw new TypeError('total should be a number')
              }

              if (!isNumber(activePage)) {
                throw new TypeError('activePage should be a number')
              }



          * * *  Pagination StoryBook

          Create an alias at:

          storybook/webpack.config.js

            const path = require('path')

            newConfig.resolve = {
              alias: {
                utils: path.join(__dirname, '..', 'src', 'utils')
              }
            }


        Abstracting the  Webpack standard config


        1. webpack.config.js
        2. webpack.prod.config.js
        3. storybook/webpack.config.js
          
        Don't Repeat Yourself!

          So...Take a look at what is inside the webpack folder of github-app:

            common.js
            dev.config.js
            prod.config.js

            

      class #69 - PropType "Shape"

      It sets a custom object type.

        const reposPropTypeShape = {
          repos: PropTypes.array.isRequired,
          pagination: PropTypes.object
        }

        AppContent.propTypes = {
          repos: PropTypes.shape(reposPropTypeShape).isRequired,
          starred: PropTypes.shape(reposPropTypeShape).isRequired,
        }

        Repos.propTypes = {
          repos: PropTypes.shape({
            repos: PropTypes.arrayOf(PropTypes.shape({
              link: PropTypes.string.isRequired,
              name: PropTypes.string.isRequired,
            })).isRequired,
            pagination: PropTypes.shape({
              total: PropTypes.number,
              activePage: PropTypes.number
            }).isRequired
          })
        }        

      class #72 Webpack v2

      Breaking Changes
      
      https://github.com/fdaciuk/workflow-reactjs
      (workflow with ReactJS + Webpack 3+)


      class #76

      Tree Shaking: comes with the WebPack 2, it discards stuff from imports that actually are not being used. So libs written in ES6 that have a lot of things may be used just for what you really need, the final bundle doesn't take everything.

      



            

              




          


      
          








      

















        










